String Methods ----


# To return a string by creating object of string ---

3.0.1 :004 > s = String.new
 => ""


# To check the encoding format ---

3.0.1 :006 > s.encoding
 => #<Encoding:ASCII-8BIT> 

# If we give a string to object and encode it with \u then it will return endoded type UTF-8 ---

3.0.1 :007 > s = String.new("Que veut dire \u{e7}a?")
 => "Que veut dire ça?" 
3.0.1 :008 > s
 => "Que veut dire ça?" 
3.0.1 :009 > s.encoding
 => #<Encoding:UTF-8> 



# To encode string with Ascii ---

3.0.1 :010 > s = String.new(encoding: 'ASCII')
 => "" 
3.0.1 :011 > s.encoding
 => #<Encoding:US-ASCII> 
3.0.1 :012 > s = String.new('foo', encoding: 'ASCII')
 => "foo" 
3.0.1 :013 > s.encoding
 => #<Encoding:US-ASCII> 
3.0.1 :014 > 



# Resize the capacity ---

3.0.1 :014 > String.new(capacity: 1)
 => "" 
3.0.1 :015 > String.new('Hello World',capacity: 1)
 => "Hello World"  
3.0.1 :018 > String.new(capacity: 1)
 => "" 
3.0.1 :019 > String.new(capacity: 4096)
 => "" 
3.0.1 :020 > s = String.new('hello', encoding: 'UTF-8', capacity: 25)
 => "hello"
 
# To convert given string by specified encoding format ---

3.0.1 :023 > "%05d" % 123
 => "00123" 
3.0.1 :024 > "%04d" % 123
 => "0123" 
3.0.1 :025 > "%95d" % 123
 => "                                                                                            123" 
3.0.1 :026 > "%05d" % 123
 => "00123" 
3.0.1 :027 > "%05e" % 123
 => "1.230000e+02" 
3.0.1 :028 > "%05f" % 123
 => "123.000000" 
3.0.1 :029 > "%05i" % 123
 => "00123" 


# Make string in fromate of Hash or array ---


3.0.1 :030 > "%-5s: %016x" % [ "ID", self.object_id ]
 => "ID   : 0000000000000118" 
3.0.1 :031 > "%-2s: %016x" % [ "ID", self.object_id ]
 => "ID: 0000000000000118" 
3.0.1 :032 > "%-3s: %016x" % [ "ID", self.object_id ]
 => "ID : 0000000000000118" 


# print string from hash ---

3.0.1 :033 > "foo = %{foo}" % {foo: 'bar'}
 => "foo = bar" 
3.0.1 :034 > "foo = %{foo}, baz = %{baz}" % {foo: 'bar', baz: 'bat'}
 => "foo = bar, baz = bat" 


# Show string multiple times ---

3.0.1 :035 > "Ho! " * 3
 => "Ho! Ho! Ho! " 
3.0.1 :036 > "Ho! " * 5
 => "Ho! Ho! Ho! Ho! Ho! " 
3.0.1 :037 > "Ho! " * 0
 => "" 


# Concatinate 2 or more strings ----

3.0.1 :038 > "Hello from " + self.to_s
 => "Hello from main" 
3.0.1 :039 > s = String.new("Hello World")
 => "Hello World" 
3.0.1 :040 > s1 = String.new("How are you")
 => "How are you" 
3.0.1 :041 > s+s1
 => "Hello WorldHow are you" 
3.0.1 :042 > 



# Concate strings with << method ---
	It will append the string in First variable 

3.0.1 :039 > s = String.new("Hello World")
 => "Hello World"
3.0.1 :040 > s1 = String.new("How are you")
 => "How are you"
3.0.1 :045 > s<<s1
 => "Hello WorldHow are you" 
.0.1 :045 > s<<s1
 => "Hello WorldHow are you" 
3.0.1 :046 > s<<33
 => "Hello WorldHow are you!" 
3.0.1 :047 > s
 => "Hello WorldHow are you!" 



# To check which string is smaller, greater or equal ----

	-1 if other_string is smaller.

	0 if the two are equal.

	1 if other_string is larger.

	nil if the two are incomparable.
	

3.0.1 :049 > s = String.new("Hello World")
 => "Hello World" 
3.0.1 :050 > s1 = String.new("How are you")
 => "How are you" 
3.0.1 :051 > s <=> s1
 => -1 
3.0.1 :052 > s1 <=> s
 => 1 
3.0.1 :053 > s <=> s
 => 0 



# Compare two strings by ( == ) OR ( === ) ---

3.0.1 :054 > s = "Foo"
 => "Foo" 
3.0.1 :055 > s
 => "Foo" 
3.0.1 :056 > s == "boo"
 => false 
3.0.1 :057 > s == "foo"
 => false 
3.0.1 :058 > s == "Foo"
 => true 

3.0.1 :059 > s === 1
 => false 
3.0.1 :060 > s === "boo"
 => false 
3.0.1 :061 > s === "Foo"
 => true 
3.0.1 :062 > s === "foo"
 => false


# To check the character is in string or not ---
	it will show index of given charector in string if not present in string then show nill.

3.0.1 :063 > 'foo' =~ /f/
 => 0 
3.0.1 :064 > 'foo' =~ /o/
 => 1 
3.0.1 :065 > 'foo' =~ /x/
 => nil 
3.0.1 :066 > 'foo' =~ /a/
 => nil 


# Access string by index ----

3.0.1 :074 > s = "Hello World"
 => "Hello World" 
3.0.1 :075 > s[5]
 => " " 
3.0.1 :076 > s[2, 5]
 => "llo W" 


# Pattern matching in string ----

3.0.1 :083 > s
 => "Hello World" 
3.0.1 :084 > s['o W']
 => "o W" 
3.0.1 :085 > s['oa']
 => nil 


# ascii_only? → true or false to check ascii or not ---

3.0.1 :086 > "abc".force_encoding("UTF-8").ascii_only?   
 => true 
3.0.1 :087 > "1abc".force_encoding("UTF-8").ascii_only?   
 => true 
3.0.1 :088 > "1Xabc".force_encoding("UTF-8").ascii_only?   
 => true 
3.0.1 :089 > "abc\u{6666}".force_encoding("UTF-8").ascii_only?
 => false 


# Use Bytesize to check size of string ----

3.0.1 :090 > s = "Hello There"
 => "Hello There" 
3.0.1 :091 > s.bytesize
 => 11 


# byteslice(integer) → new_str or nil
	byteslice(integer, integer) → new_str or nil
	byteslice(range) → new_str or nil


3.0.1 :092 > s.byteslice(2)
 => "l" 
3.0.1 :093 > s.byteslice(5)
 => " " 
3.0.1 :094 > s.byteslice(4)
 => "o" 
3.0.1 :095 > s.byteslice(2, 8)
 => "llo Ther" 
3.0.1 :096 > s.byteslice(2..8)
 => "llo The"



# capitalize → new_str
	capitalize([options]) → new_str
	Returns a copy of str with the first character converted to uppercase and the remainder to lowercase.

3.0.1 :098 > s = "hello there"
 => "hello there" 
3.0.1 :099 > s.capitalize
 => "Hello there" 



# capitalize! → str or nilclick to toggle source
capitalize!([options]) → str or nil

	It will update variable by capitalize first charector ----

3.0.1 :102 > s
 => "hello there" 
3.0.1 :103 > s.capitalize
 => "Hello there" 
3.0.1 :104 > s.capitalize!
 => "Hello there" 
3.0.1 :105 > s
 => "Hello there"



# Compare two string by ---
	casecmp(other_str) → -1, 0, 1, or nil
	Compares self and other_string, ignoring case, and returning:

		-1 if other_string is smaller.

		0 if the two are equal.

		1 if other_string is larger.

		nil if the two are incomparable

3.0.1 :107 > s.casecmp('Hello')
 => 1 
3.0.1 :108 > s.casecmp('ll')
 => -1 
3.0.1 :109 > s.casecmp('llo the')
 => -1 
3.0.1 :110 > s.casecmp('llo there')
 => -1 
3.0.1 :111 > s.casecmp('Hello there')
 => 0 
3.0.1 :112 > 'FOO'.casecmp('foo')
 => 0 
3.0.1 :113 > 'foo'.casecmp('FOO')
 => 0 




# casecmp?(other_string) → true, false, or nil ---- It is same as above but just give true or false ---

3.0.1 :114 > 'foo'.casecmp?('Foo')
 => true 
3.0.1 :115 > 'foo'.casecmp?('doo')
 => false 
3.0.1 :116 > 'Foo'.casecmp?('foo')
 => true 


# Center the string by center() ---

	center(width, padstr=' ') → new_str

3.0.1 :117 > s
 => "Hello there" 
3.0.1 :118 > s.center(20)
 => "    Hello there     " 
3.0.1 :119 > s.center(50)
 => "                   Hello there                    " 
3.0.1 :124 > s.center(50,'#')
 => "###################Hello there####################" 
3.0.1 :125 > s.center(50,'123')
 => "1231231231231231231Hello there12312312312312312312" 
3.0.1 :126 > s.center(50,'.')
 => "...................Hello there...................." 
3.0.1 :127 > 



# split string in from of elements of list ----
	in Words ---

3.0.1 :131 > s.split
 => ["Hello", "there"]


# Split string in form of elements of list ---
	in charectors ---

3.0.1 :130 > s.chars
 => ["H", "e", "l", "l", "o", " ", "t", "h", "e", "r", "e"] 



# Chomp(separator=$/) → new_str
Returns a new String with the given record separator removed from the end of str (if present). 


3.0.1 :132 > 'Hello'.chomp
 => "Hello" 
3.0.1 :134 > 'Hello'.chomp('lo')
 => "Hel" 
3.0.1 :135 > 'Hello'.chomp('ll')
 => "Hello" 
3.0.1 :136 > 'Hello'.chomp('ell')
 => "Hello" 
3.0.1 :137 > 'Hello'.chomp('Hel')
 => "Hello"
3.0.1 :138 > "hello\r\n\r\r\n".chomp('')
 => "hello\r\n\r"



# Chop → new_str
Returns a new String with the last character removed. If the string ends with \r\n, both characters are removed.

3.0.1 :139 > s
 => "Hello there" 
3.0.1 :140 > s.chop
 => "Hello ther"
3.0.1 :145 > s = "Hello World\n\r"
 => "Hello World\n\r" 
3.0.1 :146 > s
 => "Hello World\n\r" 
3.0.1 :147 > s.chop
 => "Hello World\n" 
3.0.1 :148 > s<<"\n\r"
 => "Hello World\n\r\n\r" 
3.0.1 :149 > s
 => "Hello World\n\r\n\r" 
3.0.1 :150 > 
3.0.1 :149 > s
 => "Hello World\n\r\n\r" 
3.0.1 :150 > s.chop
 => "Hello World\n\r\n" 
3.0.1 :151 > s.chop
 => "Hello World\n\r\n" 
3.0.1 :153 > s
 => "Hello World\n\r\n\r" 
3.0.1 :154 > s.chop.chop
 => "Hello World\n" 



# As the above chop method chop! will aslo slice from end the string but it will update this in variable as well ---


3.0.1 :155 > s
 => "Hello World\n\r\n\r" 
3.0.1 :156 > s.chop!
 => "Hello World\n\r\n" 
3.0.1 :157 > s
 => "Hello World\n\r\n" 
3.0.1 :158 > s.chop!.chop!
 => "Hello World" 
3.0.1 :159 > s
 => "Hello World"



# To get first charector from string ---
	chr is use for this ---

3.0.1 :160 > s
 => "Hello World" 
3.0.1 :161 > s.chr
 => "H" 


# Clear method is use to show empty string and update the variable as well.

3.0.1 :162 > s
 => "Hello World" 
3.0.1 :163 > s.clear
 => "" 
3.0.1 :164 > s
 => "" 


# To know the Ascii Code of string ---


3.0.1 :165 > s = "Hello There"
 => "Hello There"
3.0.1 :167 > s.codepoints
 => [72, 101, 108, 108, 111, 32, 84, 104, 101, 114, 101] 
3.0.1 :168 > 'A'.codepoints
 => [65] 
3.0.1 :169 > 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.codepoints
 => [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90] 
3.0.1 :170 > 

 


# Concat() to concate multiple strings together it will update the variable aslo ----

3.0.1 :170 > s
 => "Hello There" 
3.0.1 :171 > s.concat('bar', 'foo', 'wao')
 => "Hello Therebarfoowao" 
3.0.1 :172 > s1
 => "How are you" 
3.0.1 :173 > s.concat('bar', 'foo', 'wao', s1)
 => "Hello TherebarfoowaobarfoowaoHow are you" 
3.0.1 :174 > s.concat(32,'bar',32, 'foo',32, 'wao',32, s1)
 => "Hello TherebarfoowaobarfoowaoHow are you bar foo wao How are you" 
3.0.1 :175 > s
 => "Hello TherebarfoowaobarfoowaoHow are you bar foo wao How are you" 



# Count the charectors in the string ----

3.0.1 :177 > a = "hello world"
 => "hello world" 
3.0.1 :178 > a.count"llo"
 => 5 
3.0.1 :179 > b = "Hahahallo hhooww are youuuu"
 => "Hahahallo hhooww are youuuu" 
3.0.1 :180 > b.count"llo"
 => 6 
3.0.1 :181 > b.count"ooww"
 => 6 
3.0.1 :182 > b.count"ow"
 => 6 



# crypt(salt_str) → new_str ---- it cryot the string using crypt(3) standard crypt library ----

3.0.1 :183 > 'foo'.crypt("$5$rounds=1000$salt$")
 => "$5$rounds=1000$salt$sOwBWdzaQ/gPXFtLc24VstV7ZQk3/x7k0cDfKUxXsn8" 
3.0.1 :184 > a
 => "hello world" 
3.0.1 :185 > a.crypt("$5$rounds=1000$salt$")
 => "$5$rounds=1000$salt$ANkvijRhLnYnPkXt0bUaUtmvDl/cTWmfJg/TZGzxy9/" 



# Detele the charector or string from the string ----

3.0.1 :186 > a
 => "hello world" 
3.0.1 :187 > a.delete "ll"
 => "heo word" 
3.0.1 :188 > a
 => "hello world" 
3.0.1 :189 > a.delete "orl"
 => "he wd" 


# Delete all vowels 'aeiou' except 'e' ---

3.0.1 :190 > a.delete "aeiou","^e"
 => "hell wrld" 


# Delete and update within variable ---

3.0.1 :191 > a
 => "hello world" 
3.0.1 :192 > a.delete! "aeiou", "^e"
 => "hell wrld" 
3.0.1 :193 > a
 => "hell wrld" 
3.0.1 :194 > a.delete! "aeiou", "^e"
 => nil 


# Delete_prefix will show by deleting all the prefix charectors which is given as string from a string ---

3.0.1 :200 > 'hofooboo'.delete_prefix("hof")
 => "ooboo"


# Delete_suffix as same as above but just delete from the end ----

3.0.1 :203 > 'hofooboo'.delete_suffix("boo")
 => "hofoo" 



# Convert string into lowercase ---

	downcase → new_str

3.0.1 :208 > s = "Hello Friends HOW ARE YoU"
 => "Hello Friends HOW ARE YoU" 
3.0.1 :209 > s.downcase
 => "hello friends how are you" 
3.0.1 :210 > s
 => "Hello Friends HOW ARE YoU"


# To save after converting string into lower case ---

3.0.1 :211 > s
 => "Hello Friends HOW ARE YoU" 
3.0.1 :212 > s.downcase!
 => "hello friends how are you" 
3.0.1 :213 > s
 => "hello friends how are you"
3.0.1 :214 > s.downcase!
 => nil 



# Dump method of string --- 
	Returns a quoted version of the string with all non-printing characters replaced by \xHH notation and all special characters escaped.

3.0.1 :215 > 'hello'.dump
 => "\"hello\"" 
3.0.1 :216 > "'hello".dump
 => "\"'hello\"" 
3.0.1 :217 > s.dump
 => "\"hello friends how are you\"" 



# 	each_byte {|integer| block } → str
	each_byte → an_enumerator
Passes each byte in str to the given block, or returns an enumerator if no block is given.

It will give ascii value of all charecters of string as it iterate all charectors of a word.

3.0.1 :222 > 'hello'.each_byte {|c| print c, ' '}
104 101 108 108 111  => "hello" 
3.0.1 :222 > a
 => "Hello World" 
3.0.1 :223 > a.each_byte {|c| print c, ' '}
72 101 108 108 111 32 87 111 114 108 100  => "Hello World" 



# Similarly the above method ---- But it will iterate the string and return charectors ---

3.0.1 :224 > a.each_char {|c| print c, ' '}
H e l l o   W o r l d  => "Hello World" 
3.0.1 :226 > s.each_char {|c| print c, ' '}
h e l l o   f r i e n d s   h o w   a r e   y o u  => "hello friends how are you" 



# .each_codepoints method return the union code of evry charectors ---


3.0.1 :229 > a.each_codepoint{|i| print i, ' '}
72 101 108 108 111 32 87 111 114 108 100  => "Hello World"
3.0.1 :231 > "Hello\u0639".each_codepoint{|i| print i, ' '}
72 101 108 108 111 1593  => "Helloع" 



# Split string in from lines ----
	each_line(separator=$/, chomp: false) {|substr| block } → str


3.0.1 :233 > "hello\nworld".each_line {|s| p s}
"hello\n"
"world"
 => "hello\nworld"
3.0.1 :238 > "hellofriends\nhowareyou".each_line {|s| p s}
"hellofriends\n"
"howareyou"
 => "hellofriends\nhowareyou" 
3.0.1 :240 > "hellofriends\nhowareyou".each_line('l') {|s| p s}
"hel"
"l"
"ofriends\nhowareyou"
 => "hellofriends\nhowareyou" 
3.0.1 :241 > "hellofriends\nhowareyou".each_line('e') {|s| p s}
"he"
"llofrie"
"nds\nhoware"
"you"
 => "hellofriends\nhowareyou"
3.0.1 :242 > "hello\nworld".each_line(chomp: true) {|s| p s}
"hello"
"world"
 => "hello\nworld" 
3.0.1 :243 > "hello\nworld".each_line('l', chomp: true) {|s| p s}
"he"
""
"o\nwor"
"d"
 => "hello\nworld"



# Check te string is empty or not ---

3.0.1 :244 > a
 => "ع" 
3.0.1 :245 > a.empty?
 => false 
3.0.1 :246 > b.empty?
 => false 
3.0.1 :247 > b
 => "Hahahallo hhooww are youuuu" 
3.0.1 :250 > c = ""
 => "" 
3.0.1 :251 > c.empty?
 => true 



# Encoding --- Give encoding information ---

3.0.1 :259 > b.encoding
 => #<Encoding:UTF-8>



# Check the string that is containing the string at the end of first string ---

	end_with?([suffixes]+) → true or false
	Returns true if str ends with one of the suffixes given.

3.0.1 :264 > a = "Hello"
 => "Hello" 
3.0.1 :268 > a.end_with?("lo")
 => true 
3.0.1 :266 > b = "Hello World"
 => "Hello World"
3.0.1 :269 > b.end_with?("lo")
 => false 



# eql?(object) → true or false
	Returns true if object has the same length and content; as self; false otherwise:

3.0.1 :270 > a.eql?("hello")
 => false 
3.0.1 :271 > a.eql?("Hello")
 => true 
3.0.1 :272 > a.eql?("preet")
 => false 


# Freeze() method ----

3.0.1 :278 > a
 => "Hello" 
3.0.1 :279 > a.freeze()
 => "Hello" 
3.0.1 :280 > b.freeze()
 => "Hello World" 
3.0.1 :281 > b
 => "Hello World" 
3.0.1 :282 > 


# getbyte(index) → 0 .. 255
returns the indexth byte as an integer.

3.0.1 :278 > a
 => "Hello"
3.0.1 :283 > a.getbyte(1)
 => 101
3.0.1 :287 > a.getbyte(4)
 => 111 


# grapheme_clusters → an_array
	It will seprate every charectors into element of array.

3.0.1 :291 > a.grapheme_clusters
 => ["H", "e", "l", "l", "o"] 
3.0.1 :292 > b.grapheme_clusters
 => ["H", "e", "l", "l", "o", " ", "W", "o", "r", "l", "d"] 


# gsub(pattern, replacement) → new_str
gsub(pattern, hash) → new_str
gsub(pattern) {|match| block } → new_str
gsub(pattern) → enumerator

	Check the pattern and return by replaceing in sring

3.0.1 :291 > a.grapheme_clusters
 => ["H", "e", "l", "l", "o"] 
3.0.1 :292 > b.grapheme_clusters
 => ["H", "e", "l", "l", "o", " ", "W", "o", "r", "l", "d"] 
3.0.1 :293 > "hello".gsub(/[aeiou]/, '*') 
 => "h*ll*" 
3.0.1 :294 > "hello".gsub(/([aeiou])/, '<\1>')  
 => "h<e>ll<o>" 
3.0.1 :295 > "hello".gsub(/./) {|s| s.ord.to_s + ' '}
 => "104 101 108 108 111 " 
3.0.1 :296 > "hello".gsub(/(?<foo>[aeiou])/, '{\k<foo>}')
 => "h{e}ll{o}" 
3.0.1 :297 > 'hello'.gsub(/[eo]/, 'e' => 3, 'o' => '*')
 => "h3ll*" 


# Get hash of string ----
	hash --> integer

3.0.1 :298 > a.hash
 => 2061280363758546566 
3.0.1 :299 > a
 => "Hello" 



# COnvert Hex to decimal string ---

3.0.1 :301 > "0x0a".hex
 => 10 
3.0.1 :302 > "-12345".hex
 => -74565 
3.0.1 :303 > "Preet".hex
 => 0 
3.0.1 :304 > "hello".hex
 => 0 
3.0.1 :305 > "0".hex
 => 0 


# Include? other_str → true or false
	Returns true if str contains the given string or character.

3.0.1 :306 > a
 => "Hello" 
3.0.1 :307 > a.include? 'lo'
 => true 
3.0.1 :308 > a.include? 'ol'
 => false 
3.0.1 :309 > b
 => "Hello World" 
3.0.1 :310 > b.include? 'rl'
 => true 


# index(substring, offset = 0) → integer or nil
	It will show the index of first charector match in first string.

3.0.1 :312 > a
 => "Hello" 
3.0.1 :313 > a.index('o')
 => 4 
3.0.1 :314 > a.index('l')
 => 2 
3.0.1 :315 > a.index('ll')
 => 2 
3.0.1 :316 > a.index('lo')
 => 3 
3.0.1 :317 > a.index('lo', 1)
 => 3 
3.0.1 :318 > a = "Hello hello Hello"
 => "Hello hello Hello" 
3.0.1 :319 > a.index('lo', 1)
 => 3 
3.0.1 :320 > a.index('lo', 3)
 => 3 
3.0.1 :321 > a.index('lo', 4)
 => 9 
3.0.1 :322 > a.index('lo', 10)
 => 15 
3.0.1 :323 > a.index('lo', -10)
 => 9 
3.0.1 :324 > a.index('lo', -5)
 => 15 
3.0.1 :325 > a.index('lo', -15)
 => 3 



# replace(other_str) → str
	Replaces the contents of str with the corresponding values in other_str.

3.0.1 :326 > a
 => "Hello hello Hello" 
3.0.1 :327 > a.replace "How are you"
 => "How are you" 
3.0.1 :328 > a
 => "How are you" 



# insert(index, other_string) → self
	Inserts the given other_string into self; returns self.

	If the Integer index is positive, inserts other_string at offset index:

3.0.1 :328 > a
 => "How are you" 
3.0.1 :329 > a[5]
 => "r" 
3.0.1 :330 > a.insert(5, "Hello")
 => "How aHellore you" 
3.0.1 :331 > 
3.0.1 :332 > a[-5]
 => "e" 
3.0.1 :333 > a.insert(-5, "Hello")
 => "How aHelloreHello you" 


# Inspect → string
	Returns a printable version of str, surrounded by quote marks, with special characters escaped.

3.0.1 :338 > a
 => "How are you" 
3.0.1 :339 > a[5] = "\b"
 => "\b" 
3.0.1 :340 > a
 => "How a\be you" 
3.0.1 :341 > a.inspect
 => "\"How a\\be you\""



# Intern → symbol
	Returns the Symbol corresponding to str, creating the symbol if it did not previously exist.

3.0.1 :342 > a.intern
 => :"How a\be you" 
3.0.1 :343 > a.replace "Hello Wolrd"
 => "Hello Wolrd" 
3.0.1 :344 > a
 => "Hello Wolrd" 
3.0.1 :345 > a.intern
 => :"Hello Wolrd" 
3.0.1 :346 > a.to_sym
 => :"Hello Wolrd" 
3.0.1 :347 > a
 => "Hello Wolrd" 
3.0.1 :348 > s= 'cat'.to_sym
 => :cat 
3.0.1 :349 > s
 => :cat 
3.0.1 :350 > s == ':cat'
 => false 
3.0.1 :351 > s == ":cat"
 => false 
3.0.1 :352 > s
 => :cat 
3.0.1 :353 > s == :cat
 => true 
3.0.1 :354 > s = 'Dog'
 => "Dog" 
3.0.1 :355 > s = 'Dog'.to_sym
 => :Dog 
3.0.1 :356 > s == :Dog
 => true 
3.0.1 :357 > s == :dog
 => false 



# Length method is use to count the length of given string ---

3.0.1 :358 > a
 => "Hello Wolrd" 
3.0.1 :359 > a.length
 => 11 
3.0.1 :360 > 'Preet'.length
 => 5 
3.0.1 :361 > b.length
 => 11 
3.0.1 :362 > b
 => "Hello World" 
3.0.1 :363 > s.length
 => 3 
3.0.1 :364 > s
 => :Dog 
3.0.1 :365 > s1
 => "How are you" 
3.0.1 :366 > s.length
 => 3 
3.0.1 :367 > s1.length
 => 11 



# lines(separator=$/, chomp: false) → an_array
	Returns an array of lines in str split using the supplied record separator ($/ by default). This is a shorthand for str.each_line(separator, getline_args).to_a

3.0.1 :368 > s1
 => "How are you" 
3.0.1 :369 > s1.lines
 => ["How are you"] 
3.0.1 :370 > s1.lines()
 => ["How are you"] 
3.0.1 :371 > s1.lines(' ')
 => ["How ", "are ", "you"] 
3.0.1 :373 > "hello\nworld\n".lines(chomp: true)
 => ["hello", "world"] 




=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Date 13-July-2021
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

# ljust() Method
	ljust(integer, padstr=' ') → new_str
	It use to justify the string from left or if integer is greater then length of string then paded the string with the given integer

3.0.1 :002 > s = "Hello World"
 => "Hello World"
3.0.1 :004 > s.ljust(20)
 => "Hello World         " 
3.0.1 :005 > s.ljust(5)
 => "Hello World" 
3.0.1 :006 > s.ljust(20, '123')
 => "Hello World123123123" 
3.0.1 :008 > s.ljust(20, '#')
 => "Hello World#########" 


# rjust() method
	rjust(integer, padstr=' ') → new_str
	this method is use to justify the string from right and if given integer value is greater then the length of string then it will add some space or given pattern to justify the string towords right.


3.0.1 :167 > b
 => "Bye Bye !!!" 
3.0.1 :168 > b.rjust(10)
 => "Bye Bye !!!" 
3.0.1 :169 > b.rjust(15)
 => "    Bye Bye !!!" 
3.0.1 :170 > b.rjust(20)
 => "         Bye Bye !!!" 
3.0.1 :171 > b.rjust(20,'_')
 => "_________Bye Bye !!!" 
3.0.1 :172 > b.rjust(20,'#')
 => "#########Bye Bye !!!" 
3.0.1 :173 > b.rjust(50,'#')
 => "#######################################Bye Bye !!!" 
3.0.1 :174 > b.rjust(50,'123')
 => "123123123123123123123123123123123123123Bye Bye !!!" 
3.0.1 :175 > b.rjust(51,'123')
 => "1231231231231231231231231231231231231231Bye Bye !!!" 




# strip method is use to remove blank space and backspace clauses ---
	strip → new_str

3.0.1 :255 > a = " Hello "
 => " Hello " 
3.0.1 :256 > a.strip
 => "Hello" 



# TO remove space from starting the string we ue lstrip method --
	lstrip --> str
	we can say it will strip out blank space from left of string.

3.0.1 :009 > s.lstrip
 => "Hello World" 
3.0.1 :010 > a = " Hi There "
 => " Hi There " 
3.0.1 :011 > a.lstrip
 => "Hi There " 



# To update and remove space from the first possition of the string ---
	lstrip! --> str

3.0.1 :016 > s
 => "Hello World" 
3.0.1 :014 > s.lstrip!
 => nil 
3.0.1 :015 > a.lstrip!
 => "Hi There " 
3.0.1 :017 > a
 => "Hi There " 
3.0.1 :018 > a.lstrip!
 => nil 



# rstrip method is use to strip out the blank space from string but from right.
	rstrip --> str

3.0.1 :181 > " Hello World ".rstrip
 => " Hello World" 
3.0.1 :182 > " Hello World".rstrip
 => " Hello World"



# rstrip! method is use to save changes after removing blank space from the end of string --
	rstrip! --> str

3.0.1 :185 > b = ' Bye Bye !!! '
 => " Bye Bye !!! " 
3.0.1 :186 > b.rstrip!
 => " Bye Bye !!!" 
3.0.1 :187 > b
 => " Bye Bye !!!"  



# Match the pattern in the string ---
	match(pattern, offset = 0) → matchdata or nil
	match(pattern, offset = 0) {|matchdata| ... } → object

3.0.1 :025 > a
 => "Hi There " 
3.0.1 :026 > s
 => "Hello World" 
3.0.1 :027 > s.match('ll')
 => #<MatchData "ll"> 
3.0.1 :028 > s.match('lo')
 => #<MatchData "lo"> 
3.0.1 :029 > s.match('ol')
 => nil 
3.0.1 :030 > s.match('ol',3)
 => nil 
3.0.1 :031 > s.match('lo',3)
 => #<MatchData "lo"> 
3.0.1 :032 > s.match('lo',4)
 => nil 
3.0.1 :033 > a.match('There')
 => #<MatchData "There"> 
3.0.1 :034 > a.match('There',5)
 => nil 
3.0.1 :035 > a.match('There',3)
 => #<MatchData "There">
3.0.1 :037 > 'foo'.match(/o/) {|matchdata| matchdata }
 => #<MatchData "o"> 
3.0.1 :038 > a.match(/There/) {|matchdata| matchdata }
 => #<MatchData "There"> 
3.0.1 :040 > a
 => "Hi There "
3.0.1 :042 > b = "Hi"
 => "Hi" 
3.0.1 :043 > a.match(b){|matchdata| matchdata}
 => #<MatchData "Hi"> 




# Check pattern is in string or not it will show either tru or false only ---
	match?(pattern, offset = 0) → true or false
	Same as above but just return true if pattern match else false if not matched.

3.0.1 :045 > a
 => "Hi There " 
3.0.1 :046 > b
 => "Hi" 
3.0.1 :047 > s
 => "Hello World" 
3.0.1 :048 > a.match?('Hi')
 => true 
3.0.1 :049 > a.match?('hi')
 => false 
3.0.1 :050 > a.match?(b)
 => true 
3.0.1 :051 > a.match?(b,1)
 => false 
3.0.1 :052 > s.match?(b,1)
 => false 
3.0.1 :053 > s.match?(b,2)
 => false 
3.0.1 :054 > s.match?(b,)
 => false 
3.0.1 :055 > s.match?('Wo')
 => true 



# Successor method --- it is use to perform increment in the string ---
	if alphabets then or integer no matter it will increase by 1 value and by that the string will manipulate.
	succ → new_strclick

3.0.1 :056 >  b
 => "Hi" 
3.0.1 :057 > b.succ
 => "Hj" 
3.0.1 :058 > b= '123aaz99az'
 => "123aaz99az" 
3.0.1 :059 > b.succ
 => "123aaz99ba" 
3.0.1 :060 > b='99zz99'
 => "99zz99" 
3.0.1 :061 > b.succ
 => "100aa00" 
3.0.1 :062 > '***'.succ
 => "**+" 
3.0.1 :063 > '<<Hello>>'.succ
 => "<<Hellp>>" 
3.0.1 :064 > "**+".succ
 => "**," 
3.0.1 :065 > "**,".succ
 => "**-" 
3.0.1 :066 > "**-".succ
 => "**." 
3.0.1 :067 > "**.".succ
 => "**/" 
3.0.1 :068 > "**/".succ
 => "**0" 
3.0.1 :069 > "**0".succ
 => "**1" 
3.0.1 :070 > "**9".succ
 => "**10" 
3.0.1 :071 > "**10".succ
 => "**11" 


# Suppose if you want to increment and save the changes ---
	then we will use succ! method
	succ! → self

3.0.1 :075 > b
 => "100aa00" 
3.0.1 :076 > b.succ
 => "100aa01" 
3.0.1 :077 > b.succ!
 => "100aa01" 
3.0.1 :078 > b.succ!
 => "100aa02" 
3.0.1 :079 > b.succ!
 => "100aa03" 
3.0.1 :080 > b.succ!
 => "100aa04" 
3.0.1 :081 > b.succ!
 => "100aa05" 
3.0.1 :082 > b.succ!
 => "100aa06" 
3.0.1 :083 > b.succ!
 => "100aa07" 
3.0.1 :084 > b.succ!
 => "100aa08" 
3.0.1 :085 > b.succ!
 => "100aa09" 
3.0.1 :086 > b.succ!
 => "100aa10" 
3.0.1 :087 > b.succ!
 => "100aa11" 
3.0.1 :088 > b.succ!
 => "100aa12"




# Convert string to octal ---
	it will return octal digits if convergen possible else return 0.

	oct → integer

3.0.1 :090 > b
 => "100aa12" 
3.0.1 :091 > b.oct
 => 64 
3.0.1 :092 > 'a'.oct
 => 0 
3.0.1 :093 > '12'.oct
 => 10 
3.0.1 :094 > '100'.oct
 => 64 
3.0.1 :095 > '-100'.oct
 => -64 
3.0.1 :096 > '-377'.oct
 => -255 
3.0.1 :097 > '-00377'.oct
 => -255 
3.0.1 :098 > '-0a0377'.oct
 => 0 
3.0.1 :099 > '-00377hi'.oct
 => -255



# Ordinally change charector into integer ---

	ord --> integer

3.0.1 :100 > b
 => "100aa12" 
3.0.1 :101 > b.ord
 => 49 
3.0.1 :102 > 100.ord
 => 100 
3.0.1 :103 > '100'.ord
 => 49 
3.0.1 :104 > 'A'.ord
 => 65 
3.0.1 :105 > 'a'.ord
 => 97 
3.0.1 :106 > a.ord
 => 72 
3.0.1 :107 > a
 => "Hi There " 
3.0.1 :108 > "H".ord
 => 72 



# Partition method is use to make partition of string ---

	partition(sep) → [head, sep, tail]
	partition(regexp) → [head, match, tail]
	If match value is not in string then it will remain match and tail empty and let the whole string in head.

3.0.1 :109 > a
 => "Hi There " 
3.0.1 :111 > a.partition('T')
 => ["Hi ", "T", "here "] 
3.0.1 :112 > b.partition('i')
 => ["100aa12", "", ""] 
3.0.1 :113 > s.partition('i')
 => ["Hello World", "", ""] 
3.0.1 :114 > s.partition('W')
 => ["Hello ", "W", "orld"] 
3.0.1 :116 > s.partition(/W/)
 => ["Hello ", "W", "orld"] 
3.0.1 :117 > s.partition(/./)
 => ["", "H", "ello World"] 
3.0.1 :118 > s.partition(/,/)
 => ["Hello World", "", ""] 



# Same as above method but it will do opposite of partition method if match will not found then it will let the whole string in tail and let the head and match empty And if there is multiple match found then make partition from last occurance match. 
	rpartition(sep) → [head, sep, tail]
	rpartition(regexp) → [head, match, tail]

3.0.1 :176 > b
 => "Bye Bye !!!" 
3.0.1 :177 > b.partition('B')
 => ["", "B", "ye Bye !!!"] 
3.0.1 :178 > b.rpartition('B')
 => ["Bye ", "B", "ye !!!"] 
3.0.1 :180 > b.rpartition('x')
 => ["", "", "Bye Bye !!!"] 




# Prepend method --- Is reverce of append as in append the curser use to insert new data at the end but prepend method write the other string at the begning of string.
	prepend(*other_strings) → str


3.0.1 :119 > a
 => "Hi There " 
3.0.1 :120 > s
 => "Hello World" 
3.0.1 :121 > a.prepend(s)
 => "Hello WorldHi There " 
3.0.1 :122 > a.prepend('ByeBye')
 => "ByeByeHello WorldHi There " 



# Replace method --- as name prefers replacing the string with other string ---

	replace(othestring) --> otherstring

3.0.1 :128 > b
 => "100aa12" 
3.0.1 :129 > b.replace("Bye Bye !!!")
 => "Bye Bye !!!" 
3.0.1 :130 > b
 => "Bye Bye !!!"
3.0.1 :132 > s
 => "Hello World" 
3.0.1 :133 > s+b
 => "Hello WorldBye Bye !!!" 


# Reverse method ---- as name prefers it reverse the string ---

	reverse --> str

3.0.1 :136 > b
 => "Bye Bye !!!" 
3.0.1 :137 > b.reverse
 => "!!! eyB eyB" 
3.0.1 :138 > s
 => "Hello World" 
3.0.1 :139 > s.reverse
 => "dlroW olleH" 


# Same as above and if want to save changes then we can use ---
	reverse! method.
	reverse! --> str

3.0.1 :143 > b
 => "Bye Bye !!!" 
3.0.1 :144 > b.reverse!
 => "!!! eyB eyB" 
3.0.1 :146 > b.reverse!
 => "Bye Bye !!!" 



# Similar as index method rindex is also return index value but of that charector or pattern which occurs at last ---
	rindex(substring, offset = self.length) → integer or nil
	rindex(regexp, offset = self.length) → integer or nil


3.0.1 :152 > b
 => "Bye Bye !!!" 
3.0.1 :153 > s
 => "Hello World" 
3.0.1 :154 > b.rindex('by')
 => nil 
3.0.1 :155 > b.rindex('By')
 => 4 
3.0.1 :156 > b.index('By')
 => 0 
3.0.1 :157 > s.rindex('o')
 => 7 
3.0.1 :158 > s.index('o')
 => 4
3.0.1 :159 > b.rindex('By',5)
 => 4 
3.0.1 :160 > b.rindex('By',6)
 => 4 
3.0.1 :161 > b.rindex('By',2)
 => 0 
3.0.1 :162 > b.rindex('By',-2)
 => 4 
3.0.1 :163 > b.rindex('By',-9)
 => 0 
3.0.1 :164 > b.rindex('By',-11)
 => 0 
3.0.1 :165 > b.rindex('By',0)
 => 0 




# Scan method use to scan string and try to match pattern and split the string to make array or pass it to block to iterate it one by one ---

	scan(pattern) → arrayclick to toggle source
	scan(pattern) {|match, ...| block } → str 

3.0.1 :187 > b
 => " Bye Bye !!!" 
3.0.1 :188 > b.scan('b')
3.0.1 :189 > b.scan('/w+/')
 => [] 
3.0.1 :190 > b.scan('/\w+/')
 => [] 
3.0.1 :191 > b.scan(/\w+/)
 => ["Bye", "Bye"] 
3.0.1 :192 > b.scan(b)
3.0.1 :193 > b.scan(/../)
 => [" B", "ye", " B", "ye", " !", "!!"] 
3.0.1 :194 > b.scan(/.../)
 => [" By", "e B", "ye ", "!!!"] 
3.0.1 :195 > b.scan(/..../)
 => [" Bye", " Bye", " !!!"] 
3.0.1 :196 > b.scan(/(..)(..)/)
 => [[" B", "ye"], [" B", "ye"], [" !", "!!"]] 
3.0.1 :197 > b.scan(/(...)(...)/)
 => [[" By", "e B"], ["ye ", "!!!"]] 
3.0.1 :198 > b.scan(/(....)(....)/)
 => [[" Bye", " Bye"]] 
3.0.1 :199 > b.scan(/(.....)(.....)/)
 => [[" Bye ", "Bye !"]] 
3.0.1 :200 > b.scan(/(..)(..)/){|x| p x}
[" B", "ye"]
[" B", "ye"]
[" !", "!!"]
 => " Bye Bye !!!" 
3.0.1 :201 > b.scan(/(.)(.)/){|x| p x}
[" ", "B"]
["y", "e"]
[" ", "B"]
["y", "e"]
[" ", "!"]
["!", "!"]
 => " Bye Bye !!!" 
3.0.1 :202 > b.scan(/(.)(.)/){|x,y| p y,x}
"B"
" "
"e"
"y"
"B"
" "
"e"
"y"
"!"
" "
"!"
"!"
 => " Bye Bye !!!" 



# Length method is use to count the charectors in string ---
	length → integer

3.0.1 :203 > "\x80\u3042".length
 => 2 
3.0.1 :204 > "Hello23bhai*b0a))dhia#@".length
 => 23 
3.0.1 :205 > "Hello25bhai*b0a))dhia#@".length
 => 23 
3.0.1 :206 > "Hello2bhai*b0a))dhia#@".length
 => 22 
3.0.1 :207 > b.length
 => 12 



# Slicing the String we have string[] methods --

	string[index] → new_string or nil
	string[start, length] → new_string or nil
	string[range] → new_string or nil
	string[regexp, capture = 0] → new_string or nil
	string[substring] → new_string or nil
	

3.0.1 :208 > b
 => " Bye Bye !!!" 
3.0.1 :209 > b[4]
 => " " 
3.0.1 :210 > b[5]
 => "B" 
3.0.1 :212 > b[1, 6]
 => "Bye By" 
3.0.1 :213 > b[1..6]
 => "Bye By" 
3.0.1 :214 > b[1...6]
 => "Bye B" 
3.0.1 :216 > b[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, "non_vowel"]
 => " " 
3.0.1 :217 > b[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, "vowel"]
 => "e" 



# As we have the above feature to slice the strings --- 
	same here we have method to slice the strings, 
	It will modify the file as well.
	
	slice!(integer) → new_str or nil
	slice!(integer, integer) → new_str or nil
	slice!(range) → new_str or nil
	slice!(regexp) → new_str or nil
	slice!(other_str) → new_str or nil

3.0.1 :218 > b.slice!(6)
 => "y" 
3.0.1 :219 > b.slice!(2)
 => "y" 
3.0.1 :220 > b.slice!(1)
 => "B" 
3.0.1 :221 > b.slice!(1,6)
 => "e Be !" 
3.0.1 :222 > b.slice!(1..6)
 => "!!" 
3.0.1 :223 > b
 => " " 
3.0.1 :224 > b.slice!(1..6)
 => "" 




# Split method --- is to slpit the string into form of array ---

	split(pattern=nil, [limit]) → an_array
	split(pattern=nil, [limit]) {|sub| block } → str

3.0.1 :225 > " now's  the time ".split 
 => ["now's", "the", "time"] 
3.0.1 :226 > 
3.0.1 :226 > " now's  the time ".split 
 => ["now's", "the", "time"] 
3.0.1 :227 > " now's  the time ".split(' ')
 => ["now's", "the", "time"] 
3.0.1 :228 > " now's  the time".split(/ /)
 => ["", "now's", "", "the", "time"] 
3.0.1 :229 > "1, 2.34,56, 7".split(%r{,\s*})
 => ["1", "2.34", "56", "7"] 
3.0.1 :230 > "hello".split(//)
 => ["h", "e", "l", "l", "o"] 
3.0.1 :231 > "hello".split(//, 3)  
 => ["h", "e", "llo"] 
3.0.1 :232 > "hi mom".split(%r{\s*})
 => ["h", "i", "m", "o", "m"] 
3.0.1 :233 > "hi mom".split(%r{,\s*})
 => ["hi mom"] 
3.0.1 :234 > "mellow yellow".split("ello")
 => ["m", "w y", "w"] 
3.0.1 :235 > "1,2,,3,4,,".split(',')
 => ["1", "2", "", "3", "4"] 
3.0.1 :236 > "1,2,,3,4,,".split(',', 4)
 => ["1", "2", "", "3,4,,"] 
3.0.1 :237 > "1,2,,3,4,,".split(',', -4)
 => ["1", "2", "", "3", "4", "", ""] 
3.0.1 :238 > "1:2:3".split(/(:)()()/, 2)
 => ["1", ":", "", "", "2:3"] 
3.0.1 :239 > "".split(',', -1)
 => [] 



# Sqeeze method to compress the string by remove duplicates ---

	squeeze([other_str]*) → new_str

3.0.1 :244 > a.squeeze
 => "Helo World How Are you"
3.0.1 :245 > a.squeeze(" ")
 => "Hello World Howw Are you" 
3.0.1 :246 > a.squeeze('m-z')
 => "Hello World How Are you" 
3.0.1 :247 > a.squeeze('a-z')
 => "Helo World How Are you" 



# Save the compress form of string after remove duplicate charectors from string ---

	squeeze!([other_str]*) --> str


3.0.1 :250 > a.squeeze!('m-z')
 => "Hello World How Are you" 
3.0.1 :251 > a
 => "Hello World How Are you" 
3.0.1 :252 > a.squeeze!(" ")
 => nil 
3.0.1 :253 > a.squeeze!
 => "Helo World How Are you" 




# Start_with method is use to check the string is starting with given prefix or not ---
	start_with?([prefixes]+) → true or false 

3.0.1 :257 > "hello".start_with?("hell")
 => true 
3.0.1 :258 > "hello".start_with?(/H/i) 
 => true 
3.0.1 :259 > "hello".start_with?("heaven", "hell")
 => true 
3.0.1 :260 > "hello".start_with?("heaven", "paradise")
 => false 



# Change lower case letters into upper case ---

	upcase → new_str
	upcase([options]) → new_str
	Returns a copy of str with all lowercase letters replaced with their uppercase counterparts.

3.0.1 :330 > a
 => " Hello " 
3.0.1 :331 > a.upcase
 => " HELLO " 
3.0.1 :332 > b = "HelLo FriEndS"
 => "HelLo FriEndS" 
3.0.1 :333 > b.upcase
 => "HELLO FRIENDS"



# Modify string i upper case letters string --

	upcase! → str or nil
	upcase!([options]) → str or nil
	Upcases the contents of str, returning nil if no changes were made.

3.0.1 :334 > a
 => " Hello " 
3.0.1 :335 > a.upcase!
 => " HELLO " 
3.0.1 :336 > a
 => " HELLO " 
3.0.1 :337 > b
 => "HelLo FriEndS" 
3.0.1 :338 > b.upcase!
 => "HELLO FRIENDS" 
3.0.1 :339 > b
 => "HELLO FRIENDS" 



# To change upper case into lowercase and lowercase into upper case ---
	we have a method called swapcase for the same --
	
	swapcase → new_str
	swapcase([options]) → new_str

3.0.1 :261 > a
 => " Hello " 
3.0.1 :262 > a.swapcase
 => " hELLO " 
3.0.1 :266 > s
 => "Hello World" 
3.0.1 :267 > s.swapcase
 => "hELLO wORLD" 



# To convert integer in string into complex number ---

	to_c → complex
	Returns a complex which denotes the string form. The parser ignores leading whitespaces and trailing garbage. 

3.0.1 :268 > '12'.to_c
 => (12+0i)
3.0.1 :270 > '1+i'.to_c
 => (1+1i)
3.0.1 :271 > '2.5/2 + i'.to_c
 => ((5/4)+0i) 
3.0.1 :272 > '2.5 + i'.to_c
 => (2.5+0i) 
3.0.1 :273 > '2.5'.to_c
 => (2.5+0i) 
3.0.1 :274 > '2.5/2'.to_c
 => ((5/4)+0i) 
3.0.1 :275 > '3.4/2'.to_c
 => ((17/10)+0i)




# TO convert string into float ---

	to_f --> float

3.0.1 :276 > '2'.to_f
 => 2.0 
3.0.1 :277 > '100'.to_f
 => 100.0 
3.0.1 :278 > '100.34'.to_f
 => 100.34 



# To convert into integer ---

	to_i(base=10) → integer

3.0.1 :279 > "12345".to_i  
 => 12345 
3.0.1 :280 > "123.45".to_i  
 => 123 
3.0.1 :281 > "123.45 bad".to_i  
 => 123 
3.0.1 :282 > "12345 bad".to_i  
 => 12345 
3.0.1 :283 > "12345bad".to_i  
 => 12345 
3.0.1 :284 > "0a".to_i(16)
 => 10 
3.0.1 :285 > "0a".to_i(8)
 => 0 
3.0.1 :286 > "0a".to_i(10)
 => 0 
3.0.1 :287 > "0a".to_i(16)
 => 10 
3.0.1 :288 > "Hello".to_i
 => 0 
3.0.1 :289 > "1100101".to_i(2)
 => 101 
3.0.1 :290 > "1100101".to_i(8)
 => 294977 
3.0.1 :291 > "1100101".to_i(16)
 => 17826049 
3.0.1 :292 > "1100101".to_i(10)
 => 1100101 



# TO convert into rational number ---


	to_r → rational
	Returns the result of interpreting leading characters in str as a rational. Leading whitespace and extraneous characters past the end of a valid number are ignored.


3.0.1 :293 > "1100101".to_r
 => (1100101/1) 
3.0.1 :294 > "1100.101".to_r
 => (1100101/1000) 
3.0.1 :295 > "Hello".to_r
 => (0/1) 
3.0.1 :296 > "Hel100lo".to_r
 => (0/1) 
3.0.1 :297 > "200Hello".to_r
 => (200/1) 
3.0.1 :298 > "Hello500".to_r
 => (0/1) 



# Convert string into symbolls ---

	to_sym → symbol
	Returns the Symbol corresponding to str, creating the symbol if it did not previously exist.

3.0.1 :299 > "Koala".intern
 => :Koala 
3.0.1 :300 > s = 'cat'.to_sym 
 => :cat 
3.0.1 :301 > s == :cat 
 => true 
3.0.1 :302 > s = '@cat'.to_sym  
 => :@cat 
3.0.1 :303 > s == :@cat  
 => true 
3.0.1 :304 > 'cat and dog'.to_sym
 => :"cat and dog" 


# Tr method or we can say replace method ---

	tr(from_str, to_str) => new_str
	
	Returns a copy of str with the characters in from_str replaced by the corresponding characters in to_str. 
	If to_str is shorter than from_str, it is padded with its last character in order to maintain the correspondence.


3.0.1 :305 > a
 => " Hello " 
3.0.1 :306 > a.tr('el', 'ip') 
 => " Hippo " 
3.0.1 :307 > a.tr('el', '*') 
 => " H***o " 
3.0.1 :308 > a.tr('aeiou', '*') 
 => " H*ll* " 
3.0.1 :309 > a.tr('^aeiou', '*') 
 => "**e**o*" 
3.0.1 :310 > a.tr('^aeiou', 'AA*') 
 => "**e**o*" 
3.0.1 :311 > a.tr('aeiou', 'AA*') 
 => " HAll* " 
3.0.1 :312 > a.tr('aeiou', 'A*') 
 => " H*ll* " 



# Tr_s method ---
	tr_s(from_str, to_str) → new_strclick to toggle source
	Processes a copy of str as described under #tr, then removes duplicate characters in regions that were affected by the translation.

3.0.1 :314 > a.tr_s('aeiou', 'A*') 
 => " H*ll* " 
3.0.1 :315 > a.tr_s('l', 's') 
 => " Heso " 
3.0.1 :316 > a.tr_s('l', 'r') 
 => " Hero " 
3.0.1 :317 > a.tr_s('el', '*') 
 => " H*o " 


# Normalise the string ----
	unicode_normalize(form=:nfc)
	Unicode Normalization—Returns a normalized form of str, using Unicode normalizations NFC, NFD, NFKC, or NFKD. 
	The normalization form used is determined by form, which can be any of the four values :nfc, :nfd, :nfkc, or :nfkd. 
	The default is :nfc.


3.0.1 :318 > "a\u0300".unicode_normalize 
 => "à" 
3.0.1 :319 > "a\u0300".unicode_normalize(:nfc)
 => "à" 
3.0.1 :320 > a
 => " Hello " 
3.0.1 :321 > "n\u0300".unicode_normalize(:nfc)
 => "ǹ" 
3.0.1 :323 > "\u00E0".unicode_normalize(:nfd)
 => "à" 
3.0.1 :324 > "\u00E0".unicode_normalize(:nfd){|x| p x}
 => "à" 




# To Iterate a string till the charector we can use a prdefine method or iterate a pattern by this method --

	upto(other_string, exclusive = false) {|string| ... } → self
	upto(other_string, exclusive = false) → new_enumerator
	With a block given, calls the block with each String value returned by successive calls to #succ; the first value is self, the next is self.succ, and so on; the sequence terminates when value other_string is reached


3.0.1 :340 > 'a8'.upto('b7')
 => #<Enumerator: ...> 
3.0.1 :341 > 'a8'.upto('b7'){|x| p x, ' '}
"a8"
" "
"a9"
" "
"b0"
" "
"b1"
" "
"b2"
" "
"b3"
" "
"b4"
" "
"b5"
" "
"b6"
" "
"b7"
" "
 => "a8" 
3.0.1 :342 > 'a8'.upto('b7'){|x| print x, ' '}
a8 a9 b0 b1 b2 b3 b4 b5 b6 b7  => "a8" 
3.0.1 :343 > 'a8'.upto('bb7'){|x| print x, ' '}
a8 a9 b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 h0 h1 h2 h3 h4 h5 h6 h7 h8 h9 i0 i1 i2 i3 i4 i5 i6 i7 i8 i9 j0 j1 j2 j3 j4 j5 j6 j7 j8 j9 k0 k1 k2 k3 k4 k5 k6 k7 k8 k9 l0 l1 l2 l3 l4 l5 l6 l7 l8 l9 m0 m1 m2 m3 m4 m5 m6 m7 m8 m9 n0 n1 n2 n3 n4 n5 n6 n7 n8 n9 o0 o1 o2 o3 o4 o5 o6 o7 o8 o9 p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 w0 w1 w2 w3 w4 w5 w6 w7 w8 w9 x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 z0 z1 z2 z3 z4 z5 z6 z7 z8 z9 aa0 aa1 aa2 aa3 aa4 aa5 aa6 aa7 aa8 aa9 ab0 ab1 ab2 ab3 ab4 ab5 ab6 ab7 ab8 ab9 ac0 ac1 ac2 ac3 ac4 ac5 ac6 ac7 ac8 ac9 ad0 ad1 ad2 ad3 ad4 ad5 ad6 ad7 ad8 ad9 ae0 ae1 ae2 ae3 ae4 ae5 ae6 ae7 ae8 ae9 af0 af1 af2 af3 af4 af5 af6 af7 af8 af9 ag0 ag1 ag2 ag3 ag4 ag5 ag6 ag7 ag8 ag9 ah0 ah1 ah2 ah3 ah4 ah5 ah6 ah7 ah8 ah9 ai0 ai1 ai2 ai3 ai4 ai5 ai6 ai7 ai8 ai9 aj0 aj1 aj2 aj3 aj4 aj5 aj6 aj7 aj8 aj9 ak0 ak1 ak2 ak3 ak4 ak5 ak6 ak7 ak8 ak9 al0 al1 al2 al3 al4 al5 al6 al7 al8 al9 am0 am1 am2 am3 am4 am5 am6 am7 am8 am9 an0 an1 an2 an3 an4 an5 an6 an7 an8 an9 ao0 ao1 ao2 ao3 ao4 ao5 ao6 ao7 ao8 ao9 ap0 ap1 ap2 ap3 ap4 ap5 ap6 ap7 ap8 ap9 aq0 aq1 aq2 aq3 aq4 aq5 aq6 aq7 aq8 aq9 ar0 ar1 ar2 ar3 ar4 ar5 ar6 ar7 ar8 ar9 as0 as1 as2 as3 as4 as5 as6 as7 as8 as9 at0 at1 at2 at3 at4 at5 at6 at7 at8 at9 au0 au1 au2 au3 au4 au5 au6 au7 au8 au9 av0 av1 av2 av3 av4 av5 av6 av7 av8 av9 aw0 aw1 aw2 aw3 aw4 aw5 aw6 aw7 aw8 aw9 ax0 ax1 ax2 ax3 ax4 ax5 ax6 ax7 ax8 ax9 ay0 ay1 ay2 ay3 ay4 ay5 ay6 ay7 ay8 ay9 az0 az1 az2 az3 az4 az5 az6 az7 az8 az9 ba0 ba1 ba2 ba3 ba4 ba5 ba6 ba7 ba8 ba9 bb0 bb1 bb2 bb3 bb4 bb5 bb6 bb7  => "a8" 




# TO check the encode is correct or not ---
	valid_encoding? → true or false
	Returns true for a string which is encoded correctly.

3.0.1 :345 > "\xc2\xa1".force_encoding("UTF-8").valid_encoding?
 => true 
3.0.1 :346 > "\xc2".force_encoding("UTF-8").valid_encoding?
 => false 
3.0.1 :347 > "\x80".force_encoding("UTF-8").valid_encoding?
 => false 



