----------- Array Built-in Methods and practice -----------


# Creating array ---

#Using literal constructor [] Method ---

	3.0.1 :348 > arra = [3, "Preet", 12.5]
	 => [3, "Preet", 12.5]


# Using new class method ---

	3.0.1 :349 > arra = Array.new
	 => [] 

	3.0.1 :350 > arra = Array.new(5)
	 => [nil, nil, nil, nil, nil] 

	3.0.1 :352 > arra = Array.new(5, 'Preet')
	 => ["Preet", "Preet", "Preet", "Preet", "Preet"]


# Using new class method add hash as elements of array ---

	3.0.1 :354 > arra = Array.new(4) {Hash.new}
	 => [{}, {}, {}, {}] 

# Createing array using comprehension way ---

	3.0.1 :355 > arra = Array.new(4) {|i| i.to_s}
	 => ["0", "1", "2", "3"] 
	
	3.0.1 :356 > arra = Array.new(4) {|i| i.to_i}
	 => [0, 1, 2, 3] 
	
	3.0.1 :357 > arra = Array.new(4) {|i| i.to_f}
	 => [0.0, 1.0, 2.0, 3.0] 
	
	3.0.1 :358 > arra = Array.new(4) {|i| i.to_r}
	 => [(0/1), (1/1), (2/1), (3/1)] 


# Multi Dimentional Array --

	3.0.1 :359 > arra = Array.new(3) {Array.new(3) {|i| i.to_i}}
	 => [[0, 1, 2], [0, 1, 2], [0, 1, 2]]

# Creating Array using array method --

	3.0.1 :360 > arra = Array({:a => "a", :b => "b"})
	 => [[:a, "a"], [:b, "b"]]

	3.0.1 :362 > arra = Array([1,2,3,4,5])
	 => [1, 2, 3, 4, 5]

# Access the elements of array ----

	3.0.1 :363 > arra
	 => [1, 2, 3, 4, 5] 

	3.0.1 :364 > arra[2]
	 => 3 

	3.0.1 :365 > arra[5]
	 => nil 

	3.0.1 :366 > arra[4]
	 => 5 
	
	3.0.1 :367 > arra[1..4]
	 => [2, 3, 4, 5] 

	3.0.1 :368 > arra[1.-4]
	 => 3 

	3.0.1 :369 > arra[1..-4]
	 => [2] 

	3.0.1 :370 > arra[1..-3]
	 => [2, 3] 

	3.0.1 :371 > arra[1, 3]
	 => [2, 3, 4] 


# Access array using at() method --- it works on index ---

	3.0.1 :372 > arra
	 => [1, 2, 3, 4, 5] 

	3.0.1 :373 > arra.at(3)
	 => 4 

	3.0.1 :374 > arra.at(2)
	 => 3 

# Fetch method --- use to directly fetch value of given index ---
	But if element will not found at that possision or index is empty then show error
	on other hand we can give a ajustable value if index will show error then that value will trigger

	
	3.0.1 :376 > arra.fetch(1)
	 => 2 

	3.0.1 :377 > arra.fetch(100)
	(irb):377:in `fetch': index 100 outside of array bounds: -5...5 (IndexError)
		from (irb):377:in `<main>'
		from /home/beryl/.rvm/rubies/ruby-3.0.1/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
		from /home/beryl/.rvm/rubies/ruby-3.0.1/bin/irb:23:in `load'
		from /home/beryl/.rvm/rubies/ruby-3.0.1/bin/irb:23:in `<main>'

	3.0.1 :378 > arra.fetch(100, "OOps")
	 => "OOps" 


# First and Last methods --- These methods will help with get first value from array and last value from array respectively --

	3.0.1 :379 > arra.first
	 => 1 

	3.0.1 :380 > arra.last
	 => 5


# Take and Drop method ---
	Take method will get values from array upto first given integer in take method --
	Drop will do reverse of take as it will get the remaining values which is after the given value --

	3.0.1 :384 > arra = Array.new(10){|i| i = i*2}
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 

	3.0.1 :385 > arra.take(3)
	 => [0, 2, 4] 

	3.0.1 :386 > arra.drop(3)
	 => [6, 8, 10, 12, 14, 16, 18]


# Length and count methods by which we can count the total size of array ---

	3.0.1 :387 > browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
	 => ["Chrome", "Firefox", "Safari", "Opera", "IE"] 

	3.0.1 :388 > browsers.length
	 => 5 

	3.0.1 :389 > browsers.count
	 => 5 



# Check array is empty or not ---
	
	3.0.1 :391 > browsers
	 => ["Chrome", "Firefox", "Safari", "Opera", "IE"] 

	3.0.1 :392 > browsers.empty?
	 => false


# To check the given element is in array or not ---

	3.0.1 :395 > browsers
	 => ["Chrome", "Firefox", "Safari", "Opera", "IE"] 

	3.0.1 :396 > browsers.include?("Guruji")
	 => false 

	3.0.1 :397 > browsers.include?("Hello")
	 => false 


# Adding elements in array ---

	# Using Push method --

	3.0.1 :400 > arra1
	 => [0, 1, 2, 3, 4] 

	3.0.1 :401 > arra1.push(5)
	 => [0, 1, 2, 3, 4, 5] 

	3.0.1 :402 > arra1.push(5)
	 => [0, 1, 2, 3, 4, 5, 5] 

	3.0.1 :403 > arra1.push(7)
	 => [0, 1, 2, 3, 4, 5, 5, 7]

	
	# Using << operators ---

	3.0.1 :404 > arra1 << 9
	 => [0, 1, 2, 3, 4, 5, 5, 7, 9] 

	3.0.1 :405 > arra1 << 8
	 => [0, 1, 2, 3, 4, 5, 5, 7, 9, 8] 


	# Using Unshift --- it will add element at begning of array --

	3.0.1 :408 > arra1.unshift(-1)
	 => [-1, 0, 1, 2, 3, 4, 5, 5, 7, 9, 8] 

	3.0.1 :409 > arra1.unshift(-2)
	 => [-2, -1, 0, 1, 2, 3, 4, 5, 5, 7, 9, 8]

	
	# Using Insert command --- 
		It will take first argument as index and then take element to add in array elements can be multiple.
	
	3.0.1 :411 > arra1.insert(6, 10)
	 => [-2, -1, 0, 1, 2, 3, 10, 4, 5, 5, 7, 9, 8] 

	3.0.1 :412 > arra1.insert(6, 'Preet', 'Orange', 'Nitin')
	 => [-2, -1, 0, 1, 2, 3, "Preet", "Orange", "Nitin", 10, 4, 5, 5, 7, 9, 8]


	
# Remove or delete elements from array ---
	
	# Using Pop method --- this method remove element from last of array --

	3.0.1 :412 > arra1
	 => [-2, -1, 0, 1, 2, 3, "Preet", "Orange", "Nitin", 10, 4, 5, 5, 7, 9, 8] 
	
	3.0.1 :413 > arra1.pop
	 => 8 

	3.0.1 :414 > arra1.pop
	 => 9 


	# Using shift method ---
		As we seen above the unshift method is use to add element at the begning 
		similarly sift use to delete from the begining ---

	3.0.1 :415 > arra1
	 => [-2, -1, 0, 1, 2, 3, "Preet", "Orange", "Nitin", 10, 4, 5, 5, 7] 

	3.0.1 :416 > arra1.shift
	 => -2 

	3.0.1 :417 > arra1.shift
	 => -1 


	# Using Delete_at() method ---
		By this method we can delete the element by index ---

	3.0.1 :419 > arra1
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 10, 4, 5, 5, 7] 

	3.0.1 :420 > arra1.delete_at(9)
	 => 5 

	3.0.1 :421 > arra1.delete_at(7)
	 => 10 

	3.0.1 :422 > arra1
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7]


	# Using Compact method ---
		This method will use to remove nil values from array --
		Non Destractive method compact
	3.0.1 :427 > arra1
	 => [0, 1, 2, nil, 3, "Preet", "Orange", "Nitin", 4, 5, 7, nil] 

	3.0.1 :428 > arra1.compact
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7] 

	3.0.1 :429 > arra1
	 => [0, 1, 2, nil, 3, "Preet", "Orange", "Nitin", 4, 5, 7, nil]

		Destractive method Compact! -- it will save changes in the array variable. 

	3.0.1 :430 > arra1.compact!
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7] 

	3.0.1 :431 > arra1
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7]


	
	# Using Unique "uniq" method --- it will remove duplicacy from array --
		Non Destractive method Uniq
	3.0.1 :436 > arra1
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7, 2, "Orange", 5] 

	3.0.1 :437 > arra1.uniq
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7] 

	3.0.1 :438 > arra1
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7, 2, "Orange", 5] 

		Destractive method Uniq!

	3.0.1 :439 > arra1.uniq!
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7] 

	3.0.1 :440 > arra1
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7]


# Iterate the array ---

	# Using Each loop --
		
	3.0.1 :441 > arra1
	 => [0, 1, 2, 3, "Preet", "Orange", "Nitin", 4, 5, 7] 

	3.0.1 :442 > arra.each {|x| print x -= 10, ' '}
	-10 -8 -6 -4 -2 0 2 4 6 8  => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 

	3.0.1 :443 > arra.each {|x| print x *= 10, ' '}
	0 20 40 60 80 100 120 140 160 180  => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
	
		

	# Using Reverse Each Loop --

	3.0.1 :444 > browsers
	 => ["Chrome", "Firefox", "Safari", "Opera", "IE"] 
	
	3.0.1 :445 > a
	 => ""

	3.0.1 :446 > browsers.reverse_each {|i| a += "#{i}"}
	 => ["Chrome", "Firefox", "Safari", "Opera", "IE"]

	3.0.1 :447 > a
	 => "IEOperaSafariFirefoxChrome"



	# Map Method ---
		Non Destractive method Map

	3.0.1 :460 > arra1
	 => [0, 1, 2, 3, 4, 7]
	
	3.0.1 :461 > arra1.map {|i| i*2}
	 => [0, 2, 4, 6, 8, 14]

	3.0.1 :462 > arra1.map {|i| i**2}
	 => [0, 1, 4, 9, 16, 49] 

		Destractive method Map!
	
	3.0.1 :463 > arra1.map! {|i| i*2}
	 => [0, 2, 4, 6, 8, 14] 

	3.0.1 :464 > arra1
	 => [0, 2, 4, 6, 8, 14]


# Selecting Items from array ---

	
	# Using Select Method ---

		Non Destractive method Select

	3.0.1 :465 > arra1
	 => [0, 2, 4, 6, 8, 14] 

	3.0.1 :466 > arra1.select {|a| a >4}
	 => [6, 8, 14] 

	3.0.1 :467 > arra1.select {|a| a%2 ==0}
	 => [0, 2, 4, 6, 8, 14] 
	
	3.0.1 :468 > arra1.select {|a| a%3 ==0}
	 => [0, 6]

		Destractive method Select!

	3.0.1 :469 > arra1.select! {|a| a%2 ==0}
	 => nil 

	3.0.1 :470 > arra1.select! {|a| a%3 ==0}
	 => [0, 6] 

	3.0.1 :471 > arra1
	 => [0, 6]



	# Using Reject method ---

		Non Destractive method Reject	

	3.0.1 :473 > arra1
	 => [1, 2, 3, 4, 5, 6]  

	3.0.1 :475 > arra1.reject {|a| a < 3}
	 => [3, 4, 5, 6] 

	3.0.1 :476 > arra1
	 => [1, 2, 3, 4, 5, 6]

		Destractive method Reject!

	3.0.1 :477 > arra1.reject! {|a| a < 3}
	 => [3, 4, 5, 6] 

	3.0.1 :478 > arra1
	 => [3, 4, 5, 6] 



	# Drop_while method --

		Non Destractive method Drop_while

	3.0.1 :484 > arra1.drop_while {|a| a < 3 }
	 => [3, 4, 5, 6] 

	3.0.1 :485 > arra1
	 => [1, 2, 3, 4, 5, 6]

	
	
	# Delete_if method --- 

		Destractive method Delete_if

	3.0.1 :487 > arra1
	 => [1, 2, 3, 4, 5, 6] 

	3.0.1 :488 > arra1.delete_if {|a| a < 4}
	 => [4, 5, 6] 

	3.0.1 :489 > arra1
	 => [4, 5, 6] 


	# Using Keep_if method --- Destractive method--

	3.0.1 :490 > arra1 = [1, 2, 3, 4, 5, 6]
	 => [1, 2, 3, 4, 5, 6] 

	3.0.1 :491 > arra1.keep_if {|a| a < 4}
	 => [1, 2, 3] 

	3.0.1 :492 > arra1
	 => [1, 2, 3] 



# Public Intance Methods ---


1) Intersection method ---
	
	arr1 & arr_other --> new_array

	3.0.1 :493 > [1,2,3] & [3,4,2,1,0]
	 => [1, 2, 3] 

	3.0.1 :494 > arra
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 

	3.0.1 :495 > arra1
	 => [1, 2, 3] 

	3.0.1 :496 > arra1 & arra
	 => [2] 


2) Repeat an array N time ---

	array * N --> New_array
	It will return the array as the result of array N number times.

	3.0.1 :497 > arra1
	 => [1, 2, 3] 

	3.0.1 :498 > arra1 * 3
	 => [1, 2, 3, 1, 2, 3, 1, 2, 3] 


3) Concatenation of two arrays ---
	
	array1 + array2 --> New_array
	It will return the result as concatenation of other two arrays.

	3.0.1 :499 > arra
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 

	3.0.1 :500 > arra1
	 => [1, 2, 3] 

	3.0.1 :501 > arra1 + arra
	 => [1, 2, 3, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 


4) Difference in between two arrays ---


	array - array1 --> new_array

	3.0.1 :499 > arra
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 

	3.0.1 :500 > arra1
	 => [1, 2, 3]  

	3.0.1 :502 > arra1 - arra
	 => [1, 3]


5) Append in array ---
	
	array1 << object ---> array_new

	3.0.1 :504 > arra1
	 => [1, 2, 3] 

	3.0.1 :505 > arra
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 

	3.0.1 :506 > arra << arra
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, [...]]

	3.0.1 :514 > arra << 19
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, [...], 19]


6) All? Method is to check is there any NIL value in array --

	all? → true or false
	all? {|element| ... } → true or false
	all?(obj) → true or false
	This method is use to check every elements of array that is setisfing the given condition or not.


	3.0.1 :520 > arra
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 19] 

	3.0.1 :521 > arra.all?  # It will just check the elemets is not nill only
	 => true 

	3.0.1 :522 > arra.all? {|val| val % 2 == 0}  # this method check the block condition is setisfied or not.
	 => false 

	3.0.1 :523 > arra.pop
	 => 19 

	3.0.1 :524 > arra.all? {|val| val % 2 == 0}
	 => true 

	3.0.1 :525 > arra.all? {|val| val > 0}
	 => false 

	3.0.1 :526 > arra.all? {|val| val >=  0}
	 => true 

	3.0.1 :527 > arra.all?(/foo/) # Foo is a object which directly comparing with every elements of arra.
	 => false



# Any? method is use to check the elements is there or not atleast a single one --

	any? → true or false
	any? {|element| ... } → true or false
	any?(obj) → true or false

	
	3.0.1 :528 > [nil, 0, false].any?
	 => true 

	3.0.1 :529 > [nil, false].any?
	 => false 

	3.0.1 :530 > [].any?
	 => false 
	


# Assoc method is use to return either element or nil if it fround the given object at first possition in the nested array.
	assoc(obj) → found_array or nil

	3.0.1 :012 > arra
	 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, {:foo=>"Boo"}, [4, 5, 7, 9]] 

	3.0.1 :013 > arra.assoc(4)
	 => [4, 5, 7, 9] 

	3.0.1 :014 > arra.assoc(8)
	 => nil 

	3.0.1 :015 > arra.assoc(5)
	 => nil 

	3.0.1 :016 > arra.assoc(0)
	 => nil	


# At method to search element by integer ---
	at(index) → object
	Returns the element at Integer offset index; does not modify self.

	3.0.1 :017 > arra
	 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, {:foo=>"Boo"}, [4, 5, 7, 9]] 

	3.0.1 :018 > arra[0]
	 => 0 

	3.0.1 :019 > arra[1]
	 => 1 

	3.0.1 :020 > arra[10]
	 => 10 

	3.0.1 :021 > arra[12]
	 => {:foo=>"Boo"} 

	3.0.1 :022 > arra[13]
	 => [4, 5, 7, 9] 

	3.0.1 :023 > arra[13][3]
	 => 9



# Bsearch Method to search elements ---
	
	bsearch {|element| ... } → object
	bsearch → new_enumerator
	Returns an element from self selected by a binary search. self should be sorted, but this is not checked.

	By using binary search, finds a value from this array which meets the given condition in O(log n) where n is the size of the array.
	
	3.0.1 :038 > arra
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 

	3.0.1 :039 > arra.bsearch {|x| x >= 4 }
	 => 4 

	3.0.1 :040 > arra.bsearch {|x| x >= 5 }
	 => 6 

	3.0.1 :041 > arra.bsearch {|x| x >=  -1}
	 => 0 

	3.0.1 :042 > arra.bsearch {|x| x >=  100}
	 => nil 


# Bsearch_Index method of array search as above method but serch index of array.

	bsearch_index {|element| ... } → integer or nil
	bsearch_index → new_enumerator
	Searches self as described at method bsearch, but returns the index of the found element instead of the element itself.

	3.0.1 :044 > arra.bsearch_index {|x| x >= 4 }
	 => 2 

	3.0.1 :045 > arra.bsearch_index {|x| x >= 5 }
	 => 3 

	3.0.1 :046 > arra.bsearch_index {|x| x >= -1 }
	 => 0 

	3.0.1 :047 > arra.bsearch_index {|x| x >= 100}
	 => nil 


# Map method to perform condition and iterate array accordingly ---
	
	map {|element| ... } → new_array
	map → new_enumerator
	Calls the block, if given, with each element of self; returns a new Array whose elements are the return values from the block:

	3.0.1 :049 > arra
	 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 

	3.0.1 :050 > arra.map {|a| a.class}
	 => [Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, String, Float, String, Array, Hash] 

	3.0.1 :051 > arra.map
	 => #<Enumerator: ...> 

	



	map! {|element| ... } → self
	map! → new_enumerator

	Same as above just save the results of block ---


# Combination method is use to return subsets by making as much as possible combinations ---
	combination(n) {|element| ... } → self
	combination(n) → new_enumerator
	Calls the block, if given, with combinations of elements of self; returns self. The order of combinations is indeterminate.


3.0.1 :052 > a = [0, 1, 2]
3.0.1 :053 > a.combination(2) {|combination| p combination }
[0, 1]
[0, 2]
3.0.1 :054 > a = [0, 1, 2, 4, 9]
3.0.1 :055 > a.combination(2) {|combination| p combination }
[0, 1]
[0, 2]
[0, 4]
[0, 9]
[1, 4]
[1, 9]
[2, 4]
[2, 9]
[4, 9]
 => [0, 1, 2, 4, 9] 
3.0.1 :056 > a = [0, 1, 2, 4, 9]
3.0.1 :057 > a.combination(3) {|combination| p combination }
[0, 1, 2]
[0, 1, 4]
[0, 1, 9]
[0, 2, 4]
[0, 2, 9]
[0, 4, 9]
[1, 2, 4]
[1, 2, 9]
[1, 4, 9]
[2, 4, 9]
 => [0, 1, 2, 4, 9] 
3.0.1 :058 > a = [0, 1, 2, 4, 9]
3.0.1 :059 > a.combination(4) {|combination| p combination }
[0, 1, 2, 4]
[0, 1, 2, 9]
[0, 1, 4, 9]
[0, 2, 4, 9]
[1, 2, 4, 9]
 => [0, 1, 2, 4, 9] 
3.0.1 :060 > a = [0, 1, 2, 4, 9]



# Compact method is use to reduce the duplicacy to compact the array size --

	compact → new_arrayclick to toggle source
	Returns a new Array containing all non-nil elements from self:


3.0.1 :063 > a
 => [1, 2, 5, 7, 3, 2, nil, 4, 5, 9, nil] 
3.0.1 :064 > a.compact
 => [1, 2, 5, 7, 3, 2, 4, 5, 9] 


	compact! → self or nil
	Removes all nil elements from self.

3.0.1 :065 > a
 => [1, 2, 5, 7, 3, 2, nil, 4, 5, 9, nil] 
3.0.1 :066 > a.compact!
 => [1, 2, 5, 7, 3, 2, 4, 5, 9] 
3.0.1 :067 > a
 => [1, 2, 5, 7, 3, 2, 4, 5, 9]



# Concate method ---
	
	concat(*other_arrays) → self
	Adds to array all elements from each Array in other_arrays; returns self:

3.0.1 :068 > b = ['hello', 'bhai', 'how', 'are', 'you']
 => ["hello", "bhai", "how", "are", "you"] 
3.0.1 :069 > a
 => [1, 2, 5, 7, 3, 2, 4, 5, 9] 
3.0.1 :070 > a.concat(b)
 => [1, 2, 5, 7, 3, 2, 4, 5, 9, "hello", "bhai", "how", "are", "you"] 



# Count method to count all elements of array ---

	count → an_integer
	count(obj) → an_integer
	count {|element| ... } → an_integer
	Returns a count of specified elements.

3.0.1 :071 > a.count
 => 14 
3.0.1 :072 > a.count(2)
 => 2 
3.0.1 :073 > a.count(5)
 => 2 
3.0.1 :076 > a = [1, 2, 5, 7, 3, 2, 4, 5, 9,]
 => [1, 2, 5, 7, 3, 2, 4, 5, 9] 
3.0.1 :077 > a.count {|a| a> 2}
 => 6


# Iterate an array we can also use cycle method --

	cycle {|element| ... } → nil
	cycle(count) {|element| ... } → nil
	cycle → new_enumerator
	cycle(count) → new_enumerator
	
3.0.1 :076 > a = [1, 2, 5, 7, 3, 2, 4, 5, 9,]
 => [1, 2, 5, 7, 3, 2, 4, 5, 9] 

3.0.1 :078 > a.cycle
 => #<Enumerator: ...> 

3.0.1 :080 > a.cycle(2) {|a| a> 2}
 => nil 
3.0.1 :081 > a.cycle(3) {|a| a> 2}
 => nil 
3.0.1 :082 > a.cycle(3) {|a| p a}
2
5
7
3
2
4
5
9
1
2
7
2
5
9
1
2
5
7
3
2
4
5
9
 => nil 
3.0.1 :083 > a.cycle(1) {|a| p a}
1
2
5
7
3
2
4
5
9
 => nil 
3.0.1 :084 > a.cycle(1) {|a| print a, ' '}
1 2 5 7 3 2 4 5 9  => nil 
3.0.1 :085 > a.cycle(1) {|a| b.push(a)}
 => nil 
3.0.1 :086 > b
 => ["hello", "bhai", "how", "are", "you", 1, 2, 5, 7, 3, 2, 4, 5, 9]




# Delete Method to delete elemets from array ---

	delete(obj) → deleted_object
	delete(obj) {|nosuch| ... } → deleted_object or block_return
	Removes zero or more elements from self; returns self.

3.0.1 :089 > b
 => ["hello", "bhai", "how", "are", "you", 1, 2, 5, 7, 3, 2, 4, 5, 9] 
3.0.1 :090 > b.delete(5)
 => 5 
3.0.1 :091 > b
 => ["hello", "bhai", "how", "are", "you", 1, 2, 7, 3, 2, 4, 9] 
3.0.1 :092 > b.delete(5) {|a| a.to_i} 
 => 5 
3.0.1 :093 > b
 => ["hello", "bhai", "how", "are", "you", 1, 2, 7, 3, 2, 4, 9] 
3.0.1 :094 > b.delete(9) {|a| a.to_i} 
 => 9 
3.0.1 :095 > b
 => ["hello", "bhai", "how", "are", "you", 1, 2, 7, 3, 2, 4] 
3.0.1 :096 > b.delete('hello') {|a| a.to_s} 
 => "hello" 
3.0.1 :097 > b
 => ["bhai", "how", "are", "you", 1, 2, 7, 3, 2, 4] 
3.0.1 :098 > b.delete('you')
 => "you" 
3.0.1 :099 > b
 => ["bhai", "how", "are", 1, 2, 7, 3, 2, 4]



# Delete by index ---

	delete_at(index) → deleted_object or nil
	Deletes an element from self, per the given Integer index.

	When index is non-negative, deletes the element at offset index:

3.0.1 :100 > b
 => ["bhai", "how", "are", 1, 2, 7, 3, 2, 4] 
3.0.1 :101 > b.delete_at(1)
 => "how" 
3.0.1 :102 > b
 => ["bhai", "are", 1, 2, 7, 3, 2, 4] 
3.0.1 :103 > b.delete_at(-1)
 => 4 
3.0.1 :104 > b
 => ["bhai", "are", 1, 2, 7, 3, 2] 



# Delete with condtion ---

	delete_if {|element| ... } → self
	delete_if → Enumerator
	Removes each element in self for which the block returns a truthy value; returns self:

3.0.1 :107 > b
 => ["bhai", "are", 1, 2, 7, 3, 2] 
3.0.1 :108 > b.delete_if {|a| a.to_s.start_with?('b')}
 => ["are", 1, 2, 7, 3, 2] 
3.0.1 :109 > b
 => ["are", 1, 2, 7, 3, 2] 
3.0.1 :110 > b.delete_if {|a| a == 2}
 => ["are", 1, 7, 3] 
3.0.1 :111 > b
 => ["are", 1, 7, 3]



# Check deiffrence in arrays ---

	difference(*other_arrays) → new_array
	Returns a new Array containing only those elements from self that are not found in any of the Arrays other_arrays; items are compared using eql?; order from self is preserved:


3.0.1 :115 > a
 => [1, 2, 5, 7, 3, 2, 4, 5, 9] 
3.0.1 :116 > b
 => ["are", 1, 7, 3] 
3.0.1 :117 > a.difference(b)
 => [2, 5, 2, 4, 5, 9]



# Dig method --- in ruby this method is use to dig out the elements from nested arrays ---

	dig(index, *identifiers) → object
	Finds and returns the object in nested objects that is specified by index and identifiers. The nested objects may be instances of various classes

3.0.1 :118 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :119 > arra.dig(1)
 => 2 
3.0.1 :120 > arra.dig(2)
 => 4 
3.0.1 :121 > arra.dig(13)
 => [24, 5, 6, 87] 
3.0.1 :122 > arra.dig(13, 1)
 => 5 
3.0.1 :123 > arra.dig(14, 1)
 => nil 
3.0.1 :124 > arra.dig(14)
 => {:foo=>"boo"}



# Dopr method in array to drop elements of array --- it works on elements directly ---
	It will drop the elements till the range what we gave in drop(n) method as n is for range ---
	
	drop(n) → new_array
	Returns a new Array containing all but the first n element of self, where n is a non-negative Integer; does not modify self.


3.0.1 :125 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :126 > arra.drop(1)
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :127 > arra.drop(5)
 => [10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}]



# delete while block condition is setisfied ---

	drop_while {|element| ... } → new_array
	drop_while → new_enumerator
	Returns a new Array containing zero or more trailing elements of self; does not modify self

3.0.1 :127 > arra
 => [10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :128 > arra.drop_while {|element| element < 3 }
 => [4, 6, 8, 10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}]





# Each loop to iterate array ---
	
	each {|element| ... } → self
	each → Enumerator
	Iterates over array elements.

	When a block given, passes each successive array element to the block; returns self:

3.0.1 :129 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :130 > arra.each {|a| puts "#{a.class} : #{a}"}
Integer : 0
Integer : 2
Integer : 4
Integer : 6
Integer : 8
Integer : 10
Integer : 12
Integer : 14
Integer : 16
Integer : 18
String : Hello
Float : 25.87
String : Preet
Array : [24, 5, 6, 87]
Hash : {:foo=>"boo"}
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :131 > arra.each {|a| puts a}
0
2
4
6
8
10
12
14
16
18
Hello
25.87
Preet
24
5
6
87
{:foo=>"boo"}
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "Hello", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 

3.0.1 :133 > arra.each {|a| puts a; a.clear if a.to_s.start_with?('H')}
0
2
4
6
8
10
12
14
16
18
Hello
25.87
Preet
24
5
6
87
{:foo=>"boo"}
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}]




# Each loop to iterate array by index ---

	each_index {|index| ... } → self
	each_index → Enumerator
	Iterates over array indexes.

3.0.1 :135 > arra.each_index {|a| puts "#{a} : #{arra[a]}"}
1 : 2
2 : 4
3 : 6
4 : 8
5 : 10
6 : 12
7 : 14
8 : 16
9 : 18
10 : 
11 : 25.87
12 : Preet
13 : [24, 5, 6, 87]
14 : {:foo=>"boo"}
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 



# TO replace the elements in array we can also use fill method ---

	fill(obj) → self
	fill(obj, start) → self
	fill(obj, start, length) → self
	fill(obj, range) → self
	fill {|index| ... } → self
	fill(start) {|index| ... } → self
	fill(start, length) {|index| ... } → self
	fill(range) {|index| ... } → self
	Replaces specified elements in self with specified objects; returns self.

	With argument obj and no block given, replaces all elements with that one object

3.0.1 :139 > arra = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}]
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :140 > arra.fill(nil)
 => [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil] 
3.0.1 :141 > arra = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}]
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :142 > arra.fill(nil, 10)  
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, nil, nil, nil, nil] 
3.0.1 :143 > arra = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}]
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :144 > arra.fill(nil, 10..10)  
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :145 > arra = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}]
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :146 > arra.fill(nil, 10, 10)  
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil] 
3.0.1 :147 > arra = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}]
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :148 > arra.fill(nil, 10...10)  
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, "", 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :149 > arra.fill(nil, 10..10)  
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 




# Replace the array with other array's elements ---
	replace(other_array) → self
	Replaces the content of self with the content of other_array; returns self:

3.0.1 :184 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :185 > b
 => ["are", 1, 7, 3] 
3.0.1 :186 > a.replace(b)
 => ["are", 1, 7, 3] 
3.0.1 :187 > a
 => ["are", 1, 7, 3] 
3.0.1 :188 > a.replace(s)
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :189 > a
 => [0, [1, [2, 3], 4], 5] 





# Iterate array's elements using index method ----

	index(object) → integer or nil
	index {|element| ... } → integer or nil
	index → new_enumerator
	Returns the index of a specified element.

3.0.1 :150 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :151 > arra.index(12)
 => 6 
3.0.1 :152 > arra.index('Preet')
 => 12 
3.0.1 :153 > arra.index() {|a| a[13] == 24 }




# TO get First or first n elements from array ---

	first → object or nil
	first(n) → new_array
	Returns elements from self; does not modify self.

	When no argument is given, returns the first element:

3.0.1 :154 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :155 > arra.first
 => 0 
3.0.1 :156 > arra.first(5)
 => [0, 2, 4, 6, 8] 
3.0.1 :157 > arra.first(13)
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet"] 
3.0.1 :158 > arra.first(15)
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :159 > arra.first(16)
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 




# TO get last or Last n elementrs ---

	last → object or nil
	last(n) → new_array
	Returns elements from self; self is not modified.

	When no argument is given, returns the last element:

3.0.1 :192 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :193 > arra.last
 => {:foo=>"boo"} 
3.0.1 :194 > arra.last(5)
 => [nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 



# Flatten method to make nested array into single layer array --

	flatten → new_array
	flatten(level) → new_array
	Returns a new Array that is a recursive flattening of self:

	Each non-Array element is unchanged.

	Each Array is replaced by its individual elements.


3.0.1 :161 > a
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :162 > a.flatten(0)
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :163 > a.flatten(1)
 => [0, 1, [2, 3], 4, 5] 
3.0.1 :164 > a
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :165 > a.flatten(2)
 => [0, 1, 2, 3, 4, 5]


	flatten! → self or nil
	flatten!(level) → self or nil
	Replaces each nested Array in self with the elements from that Array; returns self if any changes, nil otherwise.

3.0.1 :166 > a
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :167 > a.flatten!(0)
 => nil 
3.0.1 :168 > a.flatten!(1)
 => [0, 1, [2, 3], 4, 5] 
3.0.1 :169 > a.flatten!(2)
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :170 > a.flatten!(3)
 => nil 



# Hash method for array is use to create hash of array ---
	hash is a integer value which act as encrypted.
	hash → integer
	Returns the integer hash value for self.

3.0.1 :175 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :176 > a.hash
 => 1990254612351336000 
3.0.1 :177 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :178 > b.hash
 => -2154497479121295192 
3.0.1 :179 > arra.hash
 => -4113651681482587268 


# Include method ---- to check the element is in array or not ---

	include?(obj) → true or false
	Returns true if for some index i in self, obj == self[i]; otherwise

3.0.1 :180 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :181 > a.include?(4)
 => true 
3.0.1 :182 > a.include?(6)
 => false 
3.0.1 :183 > a.include?('preet')
 => false 




# Inspect method -- to get a whole array into string ---

	inspect → new_string
	Returns the new String formed by calling method #inspect on each array element

3.0.1 :196 > a.inspect
 => "[0, [1, [2, 3], 4], 5]" 
3.0.1 :197 > arra.inspect
 => "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, \"Preet\", [24, 5, 6, 87], {:foo=>\"boo\"}]" 



# Intersection method is use to intersect multiple arrays ---
	intersection(*other_arrays) → new_array
Returns a new Array containing each element found both in self and in all of the given Arrays other_arrays; duplicates are omitted; items are compared using eql?:


3.0.1 :198 > a
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :199 > b
 => ["are", 1, 7, 3] 
3.0.1 :200 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :201 > a.intersection(b)
 => [] 
3.0.1 :202 > arra.intersection(b)
 => [] 
3.0.1 :203 > arra.intersection(a)
 => [0] 



# Join Method as name prefers, this method is use to join elements in a single string ----
	join →new_string
	join(separator = $,) → new_string
	Returns the new String formed by joining the array elements after conversion. For each element element

	Uses element.to_s if element is not a kind_of?(Array).

	Uses recursive element.join(separator) if element is a kind_of?(Array)

3.0.1 :204 > a
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :205 > a.join
 => "012345" 
3.0.1 :206 > b.join
 => "are173" 
3.0.1 :207 > arra.join
 => "02468101214161825.87Preet245687{:foo=>\"boo\"}" 
3.0.1 :208 > a.join('\n')
 => "0\\n1\\n2\\n3\\n4\\n5" 
3.0.1 :209 > a.join("\n")
 => "0\n1\n2\n3\n4\n5" 
3.0.1 :210 > a.join(" ")
 => "0 1 2 3 4 5" 
3.0.1 :211 > arra.join(" ")
 => "0 2 4 6 8 10 12 14 16 18  25.87 Preet 24 5 6 87 {:foo=>\"boo\"}" 
3.0.1 :212 > b.join(" ")
 => "are 1 7 3"




# Max method to get max element from array ---

	max → element
	max {|a, b| ... } → element
	max(n) → new_array
	max(n) {|a, b| ... } → new_array
	Returns one of the following:

	The maximum-valued element from self.

	A new Array of maximum-valued elements selected from self.	

3.0.1 :223 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :224 > a.max
 => 5 
3.0.1 :225 > a.max(3)
 => [5, 4, 3]
3.0.1 :227 > ['0', '00', '000'].max {|a, b| a.size <=> b.size }
 => "000" 


# Min Method to get minimum element from array ---

	min → element
	min { |a, b| ... } → element
	min(n) → new_array
	min(n) { |a, b| ... } → new_array
	Returns one of the following:

	The minimum-valued element from self.

	A new Array of minimum-valued elements selected from self.

	When no block is given, each element in self must respond to method <=> with an Integer.

3.0.1 :228 > a.min
 => 0 
3.0.1 :229 > a.min {|a, b| a.size <=> b.size }
 => 0 
3.0.1 :230 > a.min(3)
 => [0, 1, 2] 
3.0.1 :231 > a.min(3) {|a, b| a.size <=> b.size }
 => [2, 0, 4]



# MinMax method to get min and max value from array ---

	minmax → [min_val, max_val]
	minmax {|a, b| ... } → [min_val, max_val]

3.0.1 :232 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :233 > a.minmax
 => [0, 5] 
3.0.1 :235 > a.minmax() {|a, b| a.size <=> b.size }
 => [0, 0] 



# Check the array contains nil or nan value only ----

	none? → true or false
	none? {|element| ... } → true or false
	none?(obj) → true or false
	Returns true if no element of self meet a given criterion.

3.0.1 :236 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :237 > a.none?
 => false 
3.0.1 :238 > b
 => ["are", 1, 7, 3] 
3.0.1 :239 > b.none?
 => false 
3.0.1 :240 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :241 > arra.none?
 => false 
3.0.1 :242 > [nil, false].none?
 => true 
3.0.1 :243 > [].none?
 => true 
3.0.1 :244 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :245 > a.none? {|a| a>6}
 => true 
3.0.1 :246 > a.none? {|a| a<6}
 => false 



# One method to check the elements in array either only 1 or select one element by block condition ---

	one? → true or false
	one? {|element| ... } → true or false
	one?(obj) → true or false
	Returns true if exactly one element of self meets a given criterion.

3.0.1 :247 > a.one?
 => false 
3.0.1 :248 > a
 => [0, 1, 2, 3, 4, 5] 
3.0.1 :249 > a.one?{|a| a == 0}
 => true 
3.0.1 :250 > a.append(1, 5)
 => [0, 1, 2, 3, 4, 5, 1, 5] 
3.0.1 :251 > a.one?{|a| a == 1}
 => false 
3.0.1 :252 > a.one?(0)
 => true 
3.0.1 :253 > a.one?(1)
 => false 


# Pack method to return bufferstring according Template string ---

	pack( aTemplateString ) → aBinaryString
	pack( aTemplateString, buffer: aBufferString ) → aBufferString 

3.0.1 :256 > a = [ "a", "b", "c" ]
 => ["a", "b", "c"] 
3.0.1 :257 > a.pack("A3A3A3")
 => "a  b  c  " 
3.0.1 :258 > a.pack("a3a3a3")
 => "a\x00\x00b\x00\x00c\x00\x00" 
3.0.1 :259 > n = [ 65, 66, 67 ]
 => [65, 66, 67] 
3.0.1 :260 > n.pack("ccc")  
 => "ABC" 


# To make Subsets from a given array ---

	permutation {|element| ... } → selfclick to toggle source
	permutation(n) {|element| ... } → self
	permutation → new_enumerator
	permutation(n) → new_enumerator


3.0.1 :261 > a
 => ["a", "b", "c"] 
3.0.1 :262 > a.permutation(2) {|permutation| p permutation }
["a", "b"]
["a", "c"]
["b", "a"]
["b", "c"]
["c", "a"]
["c", "b"]
 => ["a", "b", "c"] 
3.0.1 :263 > a.permutation(-1) {|permutation| fail 'Cannot happen' }
 => ["a", "b", "c"] 
3.0.1 :264 > a.permutation(-4) {|permutation| fail 'Cannot happen' }
 => ["a", "b", "c"] 
3.0.1 :265 > a.permutation(4) {|permutation| fail 'Cannot happen' }
 => ["a", "b", "c"] 
3.0.1 :266 > a.permutation {|permutation| p permutation }
["a", "b", "c"]
["a", "c", "b"]
["b", "a", "c"]
["b", "c", "a"]
["c", "a", "b"]
["c", "b", "a"]
 => ["a", "b", "c"] 
3.0.1 :267 > a.permutation
 => #<Enumerator: ...> 
3.0.1 :268 > a.permutation(2)
 => #<Enumerator: ...> 




# Delete with help pop method ---

	pop → object or nil
	pop(n) → new_array
	Removes and returns trailing elements.

3.0.1 :269 > a
 => ["a", "b", "c"] 
3.0.1 :270 > a.pop
 => "c" 
3.0.1 :272 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, "Preet", [24, 5, 6, 87], {:foo=>"boo"}] 
3.0.1 :273 > arra.pop
 => {:foo=>"boo"} 
3.0.1 :274 > arra.pop(2)
 => ["Preet", [24, 5, 6, 87]] 




# Product method -----

	product(*other_arrays) → new_array
	product(*other_arrays) {|combination| ... } → self
	Computes and returns or yields all combinations of elements from all the Arrays, including both self and other_arrays.

	The number of combinations is the product of the sizes of all the arrays, including both self and other_arrays.

	The order of the returned combinations is indeterminate.

	When no block is given, returns the combinations as an Array of Arrays:


3.0.1 :275 > a
 => ["a", "b"] 
3.0.1 :276 > b
 => ["are", 1, 7, 3] 
3.0.1 :277 > s
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :278 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87] 
3.0.1 :279 > a.product(b)
 => [["a", "are"], ["a", 1], ["a", 7], ["a", 3], ["b", "are"], ["b", 1], ["b", 7], ["b", 3]] 
3.0.1 :280 > p = a.product(b)
 => [["a", "are"], ["a", 1], ["a", 7], ["a", 3], ["b", "are"], ["b", 1], ["b", 7], ["b", 3]] 
3.0.1 :281 > p
 => [["a", "are"], ["a", 1], ["a", 7], ["a", 3], ["b", "are"], ["b", 1], ["b", 7], ["b", 3]] 
3.0.1 :282 > s.product(arra)
 => 
[[0, 0],
 [0, 2],
 [0, 4],
 [0, 6],
 [0, 8],
 [0, 10],
 [0, 12],
 [0, 14],
 [0, 16],
 [0, 18],
 [0, nil],
 [0, 25.87],
 [[1, [2, 3], 4], 0],
 [[1, [2, 3], 4], 2],
 [[1, [2, 3], 4], 4],
 [[1, [2, 3], 4], 6],
 [[1, [2, 3], 4], 8],
 [[1, [2, 3], 4], 10],
 [[1, [2, 3], 4], 12],
 [[1, [2, 3], 4], 14],
 [[1, [2, 3], 4], 16],
 [[1, [2, 3], 4], 18],
 [[1, [2, 3], 4], nil],
 [[1, [2, 3], 4], 25.87],
 [5, 0],
 [5, 2],
 [5, 4],
 [5, 6],
 [5, 8],
 [5, 10],
 [5, 12],
 [5, 14],
 [5, 16],
 [5, 18],
 [5, nil],
 [5, 25.87]] 




# Rassoc or reverse associate method use to search value from array which have nested array last element is or not ---

	assoc(obj) → found_array or nilclick to toggle source
	Returns the first element in self that is an Array whose second element == obj:

	Returns nil if no such element is found.

3.0.1 :283 > s
 => [0, [1, [2, 3], 4], 5] 
3.0.1 :284 > s.rassoc(4)
 => nil 
3.0.1 :285 > s.rassoc(3)
 => nil 
3.0.1 :286 > s.rassoc(5)
 => nil 
3.0.1 :287 > s = [0, [1, 4], [2, 3],[3, 4], 5]
 => [0, [1, 4], [2, 3], [3, 4], 5] 
3.0.1 :288 > s.rassoc(4)
 => [1, 4]


# Reject Method --- this method left the filtered elements by condition.
	
	reject {|element| ... } → new_array
	reject → new_enumerator
	Returns a new Array whose elements are all those from self for which the block returns false or nil

3.0.1 :289 > a = [:foo, 'bar', 2, 'bat']
 => [:foo, "bar", 2, "bat"] 
3.0.1 :290 > a1 = a.reject {|element| element.to_s.start_with?('b') }
 => [:foo, 2] 
3.0.1 :291 > a1
 => [:foo, 2]



	reject! {|element| ... } → self or nil
	reject! → new_enumerator
	Removes each element for which the block returns a truthy value.


3.0.1 :294 > a
 => [:foo, "bar", 2, "bat"] 
3.0.1 :295 > a.reject! {|element| element.to_s.start_with?('b') }
 => [:foo, 2] 
3.0.1 :296 > a
 => [:foo, 2] 



# Repeat combine method ---- this method combine the subsets of elements of array and also repear elements in subset --
	like [1, 1] or [2, 2]

	repeated_combination(n) {|combination| ... } → self
	repeated_combination(n) → new_enumerator
	Calls the block with each repeated combination of length n of the elements of self; each combination is an Array; returns self. The order of the combinations is indeterminate. 


3.0.1 :298 > b
 => ["are", 1, 7, 3] 
3.0.1 :299 > a.repeated_combination(2)
 => #<Enumerator: ...> 
3.0.1 :300 > a.repeated_combination(2) {|a| p a}
[:foo, :foo]
[:foo, 2]
[2, 2]
 => [:foo, 2] 
3.0.1 :301 > b.repeated_combination(2) {|a| p a}
["are", "are"]
["are", 1]
["are", 7]
["are", 3]
[1, 1]
[1, 3]
[7, 3]
[3, 3]
 => ["are", 1, 7, 3] 
3.0.1 :302 > b.repeated_combination(3) {|a| p a}
["are", "are", "are"]
["are", "are", 1]
["are", "are", 7]
["are", "are", 3]
["are", 1, 1]
["are", 1, 7]
["are", 1, 3]
["are", 7, 7]
["are", 7, 3]
["are", 3, 3]
[1, 1, 1]
[1, 1, 7]
[1, 1, 3]
[1, 7, 7]
[1, 7, 3]
[1, 3, 3]
[7, 7, 7]
[7, 7, 3]
[7, 3, 3]
[3, 3, 3]
 => ["are", 1, 7, 3] 
3.0.1 :303 > b.repeated_combination(-1) {|a| p a}
 => ["are", 1, 7, 3] 
3.0.1 :304 > b.repeated_combination(5) {|a| p a}
["are", "are", "are", "are", "are"]
["are", "are", "are", "are", 1]
["are", "are", "are", "are", 7]
["are", "are", "are", "are", 3]
["are", "are", "are", 1, 1]
["are", "are", "are", 1, 7]
["are", "are", "are", 1, 3]
["are", "are", "are", 7, 7]
["are", "are", "are", 7, 3]
["are", "are", "are", 3, 3]
["are", "are", 1, 1, 1]
["are", "are", 1, 1, 7]
["are", "are", 1, 1, 3]
["are", "are", 1, 7, 7]
["are", "are", 1, 7, 3]
["are", "are", 1, 3, 3]
["are", "are", 7, 7, 7]
["are", "are", 7, 7, 3]
["are", "are", 7, 3, 3]
["are", "are", 3, 3, 3]
["are", 1, 1, 1, 1]
["are", 1, 1, 1, 7]
["are", 1, 1, 1, 3]
["are", 1, 1, 7, 7]
["are", 1, 1, 7, 3]
["are", 1, 1, 3, 3]
["are", 1, 7, 7, 7]
["are", 1, 7, 7, 3]
["are", 1, 7, 3, 3]
["are", 1, 3, 3, 3]
["are", 7, 7, 7, 7]
["are", 7, 7, 7, 3]
["are", 7, 7, 3, 3]
["are", 7, 3, 3, 3]
["are", 3, 3, 3, 3]
[1, 1, 1, 1, 1]
[1, 1, 1, 1, 7]
[1, 1, 1, 1, 3]
[1, 1, 1, 7, 7]
[1, 1, 1, 7, 3]
[1, 1, 1, 3, 3]
[1, 1, 7, 7, 7]
[1, 1, 7, 7, 3]
[1, 1, 7, 3, 3]
[1, 1, 3, 3, 3]
[1, 7, 7, 7, 7]
[1, 7, 7, 7, 3]
[1, 7, 7, 3, 3]
[1, 7, 3, 3, 3]
[1, 3, 3, 3, 3]
[7, 7, 7, 7, 7]
[7, 7, 7, 7, 3]
[7, 7, 7, 3, 3]
[7, 7, 3, 3, 3]
[7, 3, 3, 3, 3]
[3, 3, 3, 3, 3]
 => ["are", 1, 7, 3]



# As we seen permutaion method which use to do creates subsets of all possible elements with given size N but it will not repeate the elements in combinations where as Repeated_ Permutation is method to do repeate the elements in combinations.

	repeated_permutation(n) {|permutation| ... } → self
	repeated_permutation(n) → new_enumerator
	Calls the block with each repeated permutation of length n of the elements of self; each permutation is an Array; returns self. The order of the permutations is indeterminate.



3.0.1 :308 > b.repeated_permutation(2) {|a| p a}
["are", "are"]
["are", 1]
["are", 7]
["are", 3]
[1, "are"]
[1, 1]
[1, 7]
[1, 3]
[7, "are"]
[7, 1]
[7, 7]
[7, 3]
[3, "are"]
[3, 1]
[3, 7]
[3, 3]
 => ["are", 1, 7, 3] 
3.0.1 :309 > b.repeated_permutation(3) {|a| p a}
["are", "are", "are"]
["are", "are", 1]
["are", "are", 7]
["are", "are", 3]
["are", 1, "are"]
["are", 1, 1]
["are", 1, 7]
["are", 1, 3]
["are", 7, "are"]
["are", 7, 1]
["are", 7, 7]
["are", 7, 3]
["are", 3, "are"]
["are", 3, 1]
["are", 3, 7]
["are", 3, 3]
[1, "are", "are"]
[1, "are", 1]
[1, "are", 7]
[1, "are", 3]
[1, 1, "are"]
[1, 1, 1]
[1, 1, 7]
[1, 1, 3]
[1, 7, "are"]
[1, 7, 1]
[1, 7, 7]
[1, 7, 3]
[1, 3, "are"]
[1, 3, 1]
[1, 3, 7]
[1, 3, 3]
[7, "are", "are"]
[7, "are", 1]
[7, "are", 7]
[7, "are", 3]
[7, 1, "are"]
[7, 1, 7]
[7, 1, 3]
[7, 7, "are"]
[7, 7, 1]
[7, 7, 7]
[7, 7, 3]
[7, 3, "are"]
[7, 3, 1]
[7, 3, 7]
[7, 3, 3]
[3, "are", "are"]
[3, "are", 1]
[3, "are", 7]
[3, "are", 3]
[3, 1, "are"]
[3, 1, 1]
[3, 1, 7]
[3, 1, 3]
[3, 7, "are"]
[3, 7, 1]
[3, 7, 7]
[3, 7, 3]
[3, 3, "are"]
[3, 3, 1]
[3, 3, 7]
[3, 3, 3]
 => ["are", 1, 7, 3] 
3.0.1 :310 > b.repeated_permutation(3)
 => #<Enumerator: ...>



# Rindex or can say Reverse Index ---
	this method use to perform reverse iteration and pic the index of most last occured element which is provided to search

	rindex(object) → integer or nil
	rindex {|element| ... } → integer or nil
	rindex → new_enumerator
	Returns the index of the last element for which object == element.

 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4] 
3.0.1 :322 > arra.rindex(4)
 => 17 
3.0.1 :323 > arra.rindex(8)
 => 16


# Rotate method --- As the reverse method to get array elemets in reverse here we have a method to get reverse elements of array
	rotate → new_array
	rotate(count) → new_array
	Returns a new Array formed from self with elements rotated from one end to the other. 

3.0.1 :328 > arra.rotate
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0] 
3.0.1 :329 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4]
3.0.1 :330 > arra.rotate(5)
 => [10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2, 4, 6, 8] 
3.0.1 :331 > arra.rotate(2)
 => [4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2] 
3.0.1 :332 > arra.rotate(10)
 => [nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
3.0.1 :333 > arra.rotate(-2)
 => [8, 4, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5] 
3.0.1 :334 > arra.rotate(2)
 => [4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2] 
3.0.1 :335 > arra.rotate(-3)
 => [5, 8, 4, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6] 
3.0.1 :336 > arra.rotate(3)
 => [6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2, 4] 



	rotate! → self
	rotate!(count) → self
	Rotates self in place by moving elements from one end to the other; returns self


3.0.1 :337 > arra
 => [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4] 
3.0.1 :338 > arra.rotate!(3)
 => [6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2, 4] 
3.0.1 :339 > arra
 => [6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2, 4]


# TO get random element from array we use Sample method ---

	sample(random: Random) → object
	sample(n, random: Random) → new_ary
	Returns random elements from self.

3.0.1 :341 > b
 => ["are", 1, 7, 3] 
3.0.1 :342 > b.sample
 => 3 
3.0.1 :343 > b.sample
 => 1 
3.0.1 :344 > arra
 => [6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2, 4] 
3.0.1 :345 > arra.sample
 => 18 
3.0.1 :346 > arra.sample
 => 10 
3.0.1 :347 > arra.sample
 => 12 
3.0.1 :348 > arra.sample(3)
 => [8, 5, 4] 
3.0.1 :349 > arra.sample(3)
 => [12, 6, 14] 
3.0.1 :350 > arra.sample(3)
 => [6, 14, 25.87] 
3.0.1 :351 > arra.sample(5)
 => [16, 4, 0, 8, 3] 
3.0.1 :352 > arra.sample(5)
 => [0, 8, 10, 5, 3] 
3.0.1 :353 > arra.sample(6)
 => [16, 14, 12, nil, 25.87, 18] 
3.0.1 :354 > arra.sample(6)
 => [4, 3, 18, 6, 12, 8]




# Same as above to get random from the array we use shuffle method --

	shuffle(random: Random) → new_ary
	Returns a new array with elements of self shuffled.

3.0.1 :355 > arra.shuffle
 => [8, 18, 2, 4, 6, 16, 12, 5, nil, 3, 0, 4, 8, 6, 25.87, 10, 14, 4] 
3.0.1 :356 > arra.shuffle
 => [6, nil, 5, 4, 18, 16, 14, 6, 25.87, 2, 0, 3, 4, 10, 8, 12, 8, 4] 
3.0.1 :357 > arra.shuffle
 => [2, 14, 12, 3, 5, 8, 4, 16, 18, 4, 0, 4, 8, 10, 25.87, 6, nil, 6] 

	shuffle!(random: Random) → array
	Shuffles the elements of self in place.

3.0.1 :358 > arra
 => [6, 8, 10, 12, 14, 16, 18, nil, 25.87, 3, 4, 6, 5, 8, 4, 0, 2, 4] 
3.0.1 :359 > arra.shuffle!
 => [nil, 6, 10, 25.87, 18, 3, 6, 4, 4, 12, 2, 4, 8, 14, 16, 8, 0, 5] 
3.0.1 :360 > arra.shuffle!
 => [5, 18, 10, 8, 4, 4, 6, 8, 25.87, 0, nil, 4, 3, 16, 14, 12, 2, 6] 
3.0.1 :361 > arra
 => [5, 18, 10, 8, 4, 4, 6, 8, 25.87, 0, nil, 4, 3, 16, 14, 12, 2, 6]



# TO sort the array elements ---

	sort → new_array
	sort {|a, b| ... } → new_array
	Returns a new Array whose elements are those from self, sorted

3.0.1 :370 > arra = 'abcdefghijklmnop'.split('').shuffle
 => ["e", "b", "j", "f", "c", "h", "k", "o", "n", "l", "a", "g", "d", "p", "i", "m"] 
3.0.1 :371 > arra
 => ["e", "b", "j", "f", "c", "h", "k", "o", "n", "l", "a", "g", "d", "p", "i", "m"] 
3.0.1 :372 > arra.sort
 => ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p"]


	sort! → self
	sort! {|a, b| ... } → self
	Returns self with its elements sorted in place.

3.0.1 :374 > arra
 => ["e", "b", "j", "f", "c", "h", "k", "o", "n", "l", "a", "g", "d", "p", "i", "m"] 
3.0.1 :375 > arra.sort!
 => ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p"] 
3.0.1 :376 > arra
 => ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p"] 



# Sort_by method as same as above one but it sort by size of element ---

	sort_by! {|element| ... } → self
	sort_by! → new_enumerator
	Sorts the elements of self in place, using an ordering determined by the block; returns self.

	Calls the block with each successive element; sorts elements based on the values returned from the block.

	For duplicates returned by the block, the ordering is indeterminate, and may be unstable

3.0.1 :377 > a = ['aaaa', 'bbb', 'cc', 'd']
 => ["aaaa", "bbb", "cc", "d"] 
3.0.1 :378 > a.sort_by! {|element| element.size }
 => ["d", "cc", "bbb", "aaaa"] 
3.0.1 :379 > a
 => ["d", "cc", "bbb", "aaaa"]




# Sum method which is use to add the elements and return sum of elements ---

	sum(init = 0) → object
	sum(init = 0) {|element| ... } → object 

3.0.1 :389 > arra
 => [0, 2, 4, 6, 8] 
3.0.1 :390 > arra.sum
 => 20 
3.0.1 :391 > arra.sum(100)
 => 120 
3.0.1 :392 > a
 => ["d", "cc", "bbb", "aaaa"] 
3.0.1 :393 > a.sum('apc')
 => "apcdccbbbaaaa" 



# Take method to select elements in form of array ---

	take(n) → new_array
	Returns a new Array containing the first n element of self, where n is a non-negative Integer; does not modify self

3.0.1 :396 > a
 => ["d", "cc", "bbb", "aaaa"] 
3.0.1 :397 > a.take(1)
 => ["d"] 
3.0.1 :399 > a.take(3)
 => ["d", "cc", "bbb"]


# Take while method which filter by condition and then show elements in array ---
	take_while {|element| ... } → new_array
	take_while → new_enumerator
	Returns a new Array containing zero or more leading elements of self; does not modify self.

	With a block given, calls the block with each successive element of self; stops if the block returns false or nil; returns a new Array containing those elements for which the block returned a truthy value


	3.0.1 :402 > a.take_while {|a| a.to_s}
 => ["d", "cc", "bbb", "aaaa"] 
3.0.1 :403 > arra
 => [0, 2, 4, 6, 8] 
3.0.1 :404 > arra.take_while {|a| a>3}
 => [] 
3.0.1 :405 > arra.take_while {|a| a < 3}
 => [0, 2] 
3.0.1 :406 > arra.take_while {|a| a > 3}
 => [] 
3.0.1 :407 > arra.take_while {|a| a < 5}
 => [0, 2, 4] 
3.0.1 :408 > arra.take_while {|a| a < 8}
 => [0, 2, 4, 6] 



# Convert any datatype into array --
	to_a → self or new_array
	When self is an instance of Array, returns self

3.0.1 :425 > a = "Hello".to_s.split('').shuffle
 => ["o", "l", "H", "e", "l"] 
3.0.1 :426 > a.to_a
 => ["o", "l", "H", "e", "l"]



# To make array elements into hash ---
	to_h → new_hash
	to_h {|item| ... } → new_hash
	Returns a new Hash formed from self.

3.0.1 :420 > s.to_h
 => {1=>4, 2=>3, 3=>4} 
3.0.1 :421 > s
 => [[1, 4], [2, 3], [3, 4]]



# Transpose method --
	transpose → new_array
	Transposes the rows and columns in an Array of Arrays; the nested Arrays must all be the same size

3.0.1 :428 > s
 => [[1, 4], [2, 3], [3, 4]] 
3.0.1 :429 > s.transpose
 => [[1, 2, 3], [4, 3, 4]]



# Union method to get union of multiple arrays ---

	union(*other_arrays) → new_array
	Returns a new Array that is the union of self and all given Arrays other_arrays; duplicates are removed; order is preserved; items are compared using eql


3.0.1 :431 > a
 => ["o", "l", "H", "e", "l"] 
3.0.1 :432 > b
 => ["are", 1, 7, 3] 
3.0.1 :433 > a.union(b)
 => ["o", "l", "H", "e", "are", 1, 7, 3] 
3.0.1 :434 > a.union(s)
 => ["o", "l", "H", "e", [1, 4], [2, 3], [3, 4]] 
3.0.1 :435 > a.union(s,b)
 => ["o", "l", "H", "e", [1, 4], [2, 3], [3, 4], "are", 1, 7, 3] 




# Value at method ---
	values_at(*indexes) → new_array
	Returns a new Array whose elements are the elements of self at the given Integer indexes.

3.0.1 :436 > a
 => ["o", "l", "H", "e", "l"] 
3.0.1 :437 > a.values_at(0, 2) 
 => ["o", "H"] 
3.0.1 :438 > a.values_at(0..2) 
 => ["o", "l", "H"] 
3.0.1 :439 > a.values_at(0..3) 
 => ["o", "l", "H", "e"] 
3.0.1 :440 > a.values_at(0, 3, 1, 3)
 => ["o", "e", "l", "e"] 
3.0.1 :441 > a.values_at(0, 3, 1, 3, 5)
 => ["o", "e", "l", "e", nil] 
3.0.1 :442 > a.values_at(0, -5, 1, -6, 2)
 => ["o", "o", "l", nil, "H"] 




# Zip method is use to get multiple arrays bind together ---

	zip(*other_arrays) → new_array
	zip(*other_arrays) {|other_array| ... } → nil
	
	When no block given, returns a new Array new_array of size self.size whose elements are Arrays.

	Each nested array new_array[n] is of size other_arrays.size+1, and contains:

	The nth element of self.

	The nth element of each of the other_arrays


3.0.1 :443 > a
 => ["o", "l", "H", "e", "l"] 
3.0.1 :444 > b
 => ["are", 1, 7, 3] 
3.0.1 :445 > s
 => [[1, 4], [2, 3], [3, 4]] 
3.0.1 :446 > a.zip(b)
 => [["o", "are"], ["l", 1], ["H", 7], ["e", 3], ["l", nil]] 
3.0.1 :447 > a.zip(b,s)
 => [["o", "are", [1, 4]], ["l", 1, [2, 3]], ["H", 7, [3, 4]], ["e", 3, nil], ["l", nil, nil]] 
3.0.1 :448 > s.zip(b,a)
 => [[[1, 4], "are", "o"], [[2, 3], 1, "l"], [[3, 4], 7, "H"]] 
3.0.1 :449 > arra
 => [0, 2, 4, 6, 8] 
3.0.1 :450 > s.zip(b,a,arra)
 => [[[1, 4], "are", "o", 0], [[2, 3], 1, "l", 2], [[3, 4], 7, "H", 4]]
3.0.1 :451 > a.zip(b,s) {|a| p a}
["o", "are", [1, 4]]
["l", 1, [2, 3]]
["H", 7, [3, 4]]
["e", 3, nil]
["l", nil, nil]
 => nil



# To bind array we also can use operator "|"
	array | other_array → new_array
	Returns the union of array and Array other_array; duplicates are removed; order is preserved; items are compared using eql?


3.0.1 :452 > a
 => ["o", "l", "H", "e", "l"] 
3.0.1 :453 > b
 => ["are", 1, 7, 3] 
3.0.1 :454 > a|b
 => ["o", "l", "H", "e", "are", 1, 7, 3] 
3.0.1 :455 > a|b|s
 => ["o", "l", "H", "e", "are", 1, 7, 3, [1, 4], [2, 3], [3, 4]] 
3.0.1 :456 > a|b|s|arra
 => ["o", "l", "H", "e", "are", 1, 7, 3, [1, 4], [2, 3], [3, 4], 0, 2, 4, 6, 8] 



